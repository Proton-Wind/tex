%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                      %
%      kpic.sty                                                        %
%        Extended of "eclarith.sty"                                    %
%        for picture of Mathematics                                    %
%                          Since 1998.12  By Nobuyoshi Ishino          %
%                                    (nob.asaoka@jcom.home.ne.jp)      %
%                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1.98.3 から 1.98.4 への変更は、変数のスリム化
\def\KPicVersion{1.98.4}\def\KPicDate{2000/10/11}
% 1.98.4 から 1.98.5 への変更は、座標軸の文字の変更を出来るようにした
\def\KPicVersion{1.98.5}\def\KPicDate{2001/04/25}
% 1.98.5 から 1.98.55 への変更は、金沢氏への要望に対応して\Tnodeを追加
\def\KPicVersion{1.98.55}\def\KPicDate{2005/09/06}%  非公開
% 1.98.55 から 1.98.7 への変更は、金沢氏の文章で作図の最後に格子をとる
% と書いてあったので初めにスイッチを作り一箇所だけ変更で済むようにした
\def\KPicVersion{1.98.7}\def\KPicDate{2009/06/07}%  非公開
% 1.98.7 から 2.00 への変更は次のとおり
%  ・node座標で点を表示非表示のスイッチを作成したつもりが駄目だったので保留
%  ・長年の目標であった座標軸に弧度法表示ができるようにした
% この弧度法表示ができたので、バージョンを2.00にした
% πのマイナス表示が出ないバグを修正
% 20101103-20101106
% KDotの点線をeepic.styのdottedlinedに託していたが、間隔が違うので新たに作り直した
% とりあえず未発表なのでver2.00のまま
\def\KPicVersion{2.00}\def\KPicDate{2010/11/06}
% 格子の間隔で第２パラメータ(x軸平行の値)に０を入れると無限ループに入るのを回避
\def\KPicVersion{2.01}
% 円の内部に45°の斜め線で領域を表示できる\hatchcircle、\hatchrcircleを作成した
% \KnodeLB,\KnodeLT,\KnodeRB,\KnodeRTでPic環境の四隅を定義できるようにした
% \hatch,\hatchr でKPicの座標名を使用できるよう拡張した
% 直線をPic環境を通る時の左側(\KLineLeftEdge)と右側(\KLineRightEdge)と両方(\KLineBothEdge)の境界の点の座標名を定義できるようにした
\def\KPicVersion{2.1}
% 環境全体に座標軸を自動で作成する\KAxesAutoと斜線を引く\hatchAll、\hatchrAllを作成した
% 定義した点のx座標だけ，y座標だけ取り出した\CnodeX,\CnodeYを定義した
\def\KPicVersion{2.12}\def\KPicDate{2011/05/07}
% 定義した点から座標軸へ点線を引く \PointDotX,\PointDotY,\PointDotXY を作成した
% 定義した点から座標軸へ破線を引く \PointDashX,\PointDashY,\PointDashXY を作成した
% 指定した閉塞領域の図形を消す \AreaClear を定義した
% \hatch,\hatchrを座標名で定義した時、左下→右上の規制を無くし対角の長方形の座標とした
% \hatchAllの原点Oの表示を原点の４箇所に出来るようにした
\def\KPicVersion{2.13}\def\KPicDate{2011/08/02}
% \PointDashX,\PointDashY,\PointDashXY を手直しした
% \AxesCrossX,\AxesCrossY を定義した
\def\KPicVersion{2.14}\def\KPicDate{2011/08/09}
% \hatchrcircleのバクを修正
\def\KPicVersion{2.15}\def\KPicDate{2011/10/09}
% \@CircumcenterSubで小数付の0.0と0の違いを認識せず、(0.0,0.0)(0,0)の距離計算をeclarith.styの\Distanceに渡していたのを修正
% \@KDashArcから\@KArcMainに\@KDashfalseを移した
% ver.2.01からこの２つのみ変更したver.2.02を公開した(20111229)
\def\KPicVersion{2.16}\def\KPicDate{2011/12/29}
% 四角形の内部の領域を図示する線の幅と傾きを指定できる \Khatch を作成した
% 上記の座標にKnode系の座標を使用できるようにした
% 環境全体に領域を図示する線の幅と傾きを指定できる \KhatchAll を作成した
% 円の内部の領域を図示する線の幅と傾きを指定できる \Khatchcircle を作成した
% 1本の直線の上下の領域を表示する \LineUpper(Lower)Domain を作成した
% 上を2つ使用することで連立方程式の共有範囲を図示できるようになった
% 円の内部と外部の領域を１つのコマンドで表示できるようにした
% 円の直線の共有部分を表示できるようにした
\def\KPicVersion{2.17}\def\KPicDate{2012/01/03}
% \hatch,\hatchr の拡張マクロを \Khatch に含んだためこのバージョンより削除(日の目を見なかった！)
% 環境の４つの角を一括で定義できる \KnodeCorner を作成した
\def\KPicVersion{2.18}\def\KPicDate{2012/01/04}
% 斜線の間隔を\KDomainIntervalで\unitlengthに因らず絶対的な値にした、また傾きを変えても線の幅が変わらないようにもした
% \@KDashArcから\@KArcMainに\@KDashfalseを移したために\KLineDashArc等のマクロで後半が破線にならなくなったバグを修正
% 領域と文字が重なるときに下を白くする\Maskingを作成した
% 上を使用して\AxesAuto を実行するとき原点、ｘ軸、ｙ軸をcolorパッケージを読み込んでいるときにバックを白くした
\def\KPicVersion{2.19}\def\KPicDate{2012/01/07}
% 斜線を消すとわずかだが点が残る。斜めにした直線のゴミのようだ。\LineDomainSub@をいじくる
% 上の直しで境界を含まないために太線を引けば良い事がわかり作成した
\def\KPicVersion{2.20}\def\KPicDate{2012/01/08}
% スリム化
\def\KPicVersion{2.21}\def\KPicDate{2012/01/09}
% KMhiteMasking を \KMasking に変更
% KMasking で余白にpaddingを設定
\def\KPicVersion{2.22}\def\KPicDate{2012/01/21}
% \KLineArc,\KVecArc,\KLineArc の片側が点線になるバクをとりました
\def\KPicVersion{2.23}\def\KPicDate{2012/01/28}
% \IntersectionOfTangent を作成 \Intersectionの内部マクロも変更しています
\def\KPicVersion{2.24}\def\KPicDate{2012/07/23}
% \KAxes で0の時の矢印と原点を表示しないようにした
% \KScale で0のとき、原点にも目盛りを振るようにした
% \KScaleNumber で0のとき座標に普通の0を表示するようにした
\def\KPicVersion{2.25}\def\KPicDate{2012/08/14}
% \KPath の前で \KVec 等の矢印を表示するときのエラーを解消した
% (\KPath が3文字以上対応なのに \KVec 等が2文字までのため)
% \KVec 等で矢印塗れないのを \ArrowKArc のルーチンを使用して塗れるようにした
% 第1章の座標軸を表示しない命令を追加した 
\def\KPicVersion{2.26}\def\KPicDate{2019/12/31}
%
%	上矢部高校図形マクロ KPIC
%

%%
%% KPIC.STYでは以下のスタイルファイルをここで読み込みますので、
%% あらかじめ用意しておいて下さい
%%
\input epic.sty\relax
\input eepic.sty\relax
\input eclarith.sty\relax

%% メッセージ表示
\typeout{This is KPIC(Kamiyabe high school PICture) Version  \KPicVersion}
\typeout{Released   \KPicDate   By Nob}

%% 次の２行は「eclarith.sty」からのコピー。
%% このファイルの最後に戻している
%% [説明]
%% 現在の「!」のカテゴリーコードを「orig@colon」の待避
%% そして、「!」のカテゴリーコードを11(letter)にする
%% 何でこんな事をするのかというと、「!」をマクロ名に出来るから
\edef\orig@colon{\the\catcode`\!}
\catcode`\!=11

\newdimen\K!xx
\newdimen\K!yy
%% 次の値は\unitlengthの大きさに関係なくこの長さになる
\newdimen\WordSep  \WordSep=3mm% 点と文字の間隔
\newdimen\NintyLen \NintyLen=2mm% \KNintyの直角の一辺の大きさ
\newdimen\AngleLen \AngleLen=10mm% 角の大きさ(直径)
\newdimen\FrameLen \FrameLen=0.8pt% Pic環境の枠線の太さ
\newdimen\KDotSpace \KDotSpace=1mm% \Gridでの１単位の中の点の間隔
\newdimen\KBullet \KBullet=1mm% \bulletnodetrueの時に置く点の直径
\newdimen\KVecHeadSize \KVecHeadSize=3mm% \KVecの矢の長さ
\newdimen\KAxesLen \KAxesLen=0.8pt% Axes環境の座標軸の太さ
\newdimen\KAxesLabelSep \KAxesLabelSep=3mm% Axes環境の座標軸のlabelの距離
\newdimen\KSmallScaleLen \KSmallScaleLen=0.5mm% \KScaleの軸のから長さ
\newdimen\KLargeScaleLen \KLargeScaleLen=1mm% \KScaleの軸のから長さ
\newdimen\KArrowLen \KArrowLen=2mm% 一般角の矢印の長さ
\newdimen\KDashArcLine \KDashArcLine=1mm% 円弧の破線の表示部分の長さ
\newdimen\KDashArcSpace \KDashArcSpace=0.5mm% 円弧の破線の空白部分の長さ
\newdimen\KLineArcLenS \KLineArcLenS=4mm% \KLineで表示する文字にかからないようにする開始方向の空白の長さ
\newdimen\KLineArcLenE \KLineArcLenE=4mm% \KLineで表示する文字にかからないようにする終了方向の空白の長さ
\newdimen\KDomainInterval  \KDomainInterval=0.7071mm% 斜線での間隔の幅
\newdimen\KDomainLineBetween  \KDomainLineBetween=1.75mm% 領域と線との差(1.75mm=5pt)
\newdimen\KMaskingPadding  \KMaskingPadding=0pt% マスキングする文字の周りの余白

% 計算した数字を表示する場合の小数点以下の桁数
% マイナスの値を入力するとそのままの値を表示
% 初期値は、小数第１位まで表示(第２位を四捨五入)
\def\KFigure{1}

% \Cnodeで座標を表示した場合のカンマの後の空白
\def\KSpace{\ }

%-----------------------------------------------
% ベクトル演算を定義するマクロをVer.2で定義
%-----------------------------------------------
% LaTeX自由自在 P197 のマクロを参考に変更
%-----------------------------------------------
% スカラーの平均は、「eclarith.sty」で定義されていないので定義
\def\Avg#1#2#3{% (#1 + #2)/2 = #3
  \Add{#1}{#2}{#3}
  \Div{#3}{2}{#3}}

%-----------------------------------------------
% 1.和
% (#1,#2) と (#3,#4) の和を (#5,#6) へ書き出す
\def\VecAdd(#1,#2)(#3,#4)(#5,#6){% ((#1,#2) + (#3,#4)) = (#5,#6)
   \Add{#1}{#3}{#5}\Add{#2}{#4}{#6}}

% 名前で定義された変数を #3 へ書き出す
\def\@VecAdd#1#2#3{%                \@VecAdd\A\B\C
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1#2(\!!x,\!!y)}%    \!!Vec = \A\B(\!!x,\!!y)
  \expandafter\VecAdd\!!Vec%      \!!Vec を展開して\@VecAddへ渡す
  \edef#3{(\!!x,\!!y)}}%           (\!!x,\!!y)を\Cで定義

% \@VecAdd と同じだが、#1 に２点の座標が入っている
\def\@KVecAdd#1#2{%
  \let\!!x=\relax \let\!!y=\relax
  \edef\!!Vec{#1(\!!x,\!!y)}%
  \expandafter\VecAdd\!!Vec
  \edef#2{(\!!x,\!!y)}}

%-----------------------------------------------
% 2.差
% (#1,#2) と (#3,#4) の差を (#5,#6) へ書き出す
\def\VecSub(#1,#2)(#3,#4)(#5,#6){% ((#1,#2) - (#3,#4)) = (#5,#6)
   \Sub{#1}{#3}{#5}\Sub{#2}{#4}{#6}}

% 名前で定義された変数を #3 へ書き出す
\def\@VecSub#1#2#3{%                \Vec\A\B\C
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1#2(\!!x,\!!y)}%    \!!Vec = \A\B(\!!x,\!!y)
  \expandafter\VecSub\!!Vec%      \!!Vec を展開して\@VecSubへ渡す
  \edef#3{(\!!x,\!!y)}}%           (\!!x,\!!y)を\Cで定義

% \@VecSub と同じだが、#1 に２点の座標が入っている
\def\@KVecSub#1#2{%
  \let\!!x=\relax \let\!!y=\relax
  \edef\!!Vec{#1(\!!x,\!!y)}%
  \expandafter\VecSub\!!Vec
  \edef#2{(\!!x,\!!y)}}

%-----------------------------------------------
% 3.平均
% (#1,#2) と (#3,#4) の平均を (#5,#6) へ書き出す
\def\VecAvg(#1,#2)(#3,#4)(#5,#6){% ((#1,#2) + (#3,#4)) / 2 = (#5,#6)
   \Avg{#1}{#3}{#5}\Avg{#2}{#4}{#6}}

% 名前で定義された変数を #3 へ書き出す
\def\@VecAvg#1#2#3{%                \Vec\A\B\C
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1#2(\!!x,\!!y)}%    \!!Vec = \A\B(\!!x,\!!y)
  \expandafter\VecAvg\!!Vec%      \!!Vec を展開して\@VecAvgへ渡す
  \edef#3{(\!!x,\!!y)}}%           (\!!x,\!!y)を\Cで定義

% \@VecAvg と同じだが、#1 に２点の座標が入っている
\def\@KVecAvg#1#2{%
  \let\!!x=\relax \let\!!y=\relax
  \edef\!!Vec{#1(\!!x,\!!y)}%
  \expandafter\VecAvg\!!Vec
  \edef#2{(\!!x,\!!y)}}

%-----------------------------------------------
% 4.ベクトルの実数倍
% (#1,#2) を #3倍して (#4,#5) へ書き出す
\def\SVecMul(#1,#2)#3(#4,#5){% #3(#1,#2) = (#4,#5)
   \Mul{#1}{#3}{#4}\Mul{#2}{#3}{#5}}

% 名前で定義された変数を #3 へ書き出す
\def\@SVecMul#1#2#3{%                \@SVecMul\A{3}\B
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1#2(\!!x,\!!y)}%    \!!Vec = \A{3}(\!!x,\!!y)
  \expandafter\SVecMul\!!Vec%      \!!Vec を展開して\@SVecMulへ渡す
  \edef#3{(\!!x,\!!y)}}%           (\!!x,\!!y)を\Bで定義

% \@SVecMul と同じだが、#1 に座標とスカラー倍が入っている
\def\@KSVecMul#1#2{%
  \let\!!x=\relax \let\!!y=\relax
  \edef\!!Vec{#1(\!!x,\!!y)}%
  \expandafter\SVecMul\!!Vec
  \edef#2{(\!!x,\!!y)}}

%-----------------------------------------------
% 5.単位ベクトルの計算(eclairthに定義されているので文字かだけ)
% 名前で定義されたベクトルの単位ベクトルを #2 へ書き出す
\def\@VecUnit#1#2{%                \Vec\A\B\C
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1(\!!x,\!!y)}%    \!!Vec = \A\B(\!!x,\!!y)
  \expandafter\Unit\!!Vec%      \!!Vec を展開して\Unitへ渡す
  \edef#2{(\!!x,\!!y)}}%           (\!!x,\!!y)を\Cで定義
%-----------------------------------------------


%===============================================
%        環境の定義
%===============================================
% \@KFrameAxes(#1,#2)(#3,#4)
%    座標の左下と右上を記憶しておきます
%    主目的・・・作成予定のKGraph.styでグラフを書いたとき、
%                枠からはみ出ないようにする
%
\def\@KFrameAxes(#1,#2)(#3,#4){\@killglue%
	\edef\@KFrameLeft{#3}
	\edef\@KFrameBottom{#4}
	\Add{#3}{#1}\!Kt
	\edef\@KFrameRight{\!Kt}
	\Add{#4}{#2}\!Kt
	\edef\@KFrameTop{\!Kt}
\ignorespaces}% End of \@KFrameAxes

%-----------------------------------------------
% \@PicCalcCenter(#1,#2)(#3,#4)
% 中心を原点にするように、左隅の座標を計算する内部マクロ
\def\@PicCalcCenter(#1,#2)(#3,#4){\@killglue%
	\Div{#1}{2}{\!!x}\Mul{\!!x}{-1}{\!!x}
	\Div{#2}{2}{\!!y}\Mul{\!!y}{-1}{\!!y}
	\let#3\!!x
	\let#4\!!y
\ignorespaces}% End of \@PicCalcCenter


\newif\ifkframe % \kframetrueでフレームを描く
\newif\ifkdot % \kdottrueで点線格子を描く
\newif\ifkgrid % \kgridtrueで格子を描く
\newif\ifkscale % \kscaletrueで格子を描く
\newif\ifkaxes % \kaxestrueで座標軸を描く
\newif\ifkaxesnolabel % \kaxesnolabeltrueでx,y,oを描かない
\newif\ifkaxeslabelXY % \kaxesnolabeltrueでx,yしか描かない
\newif\ifkaxeslabelO % \kaxesnolabeltrueでoしか描かない
\newif\ifkdraw % \ifkdrawtrueでGridする 20090607作成
\newif\ifknoaxes % \ifknoaxestrue でxy座標軸に矢印を描かない 20191231 kpic226
\newif\ifknoaxesX % \ifknoaxestrue でx座標軸に矢印を描かない 20191231 kpic226
\newif\ifknoaxesY % \ifknoaxestrue でy座標軸に矢印を描かない 20191231 kpic226
%===============================================
% \PicFrame環境
%===============================================
% \PicFrameC(#1,#2)
\def\PicFrameC{\kframetrue\AxesC@[1]}
\def\endPicFrameC{\end{picture}}
%-----------------------------------------------
% \PicFrame(#1,#2)[(#3,#4)] 
\def\PicFrame{\kframetrue\Pic}
\def\endPicFrame{\end{picture}}
%===============================================
% \PicFrameDot環境
%===============================================
% \PicFrameDotC[#1](#2,#3)
\def\PicFrameDotC{\kframetrue\kdottrue\@ifnextchar[{\AxesC@}{\AxesC@[1]}}
\def\endPicFrameDotC{\end{picture}}
%-----------------------------------------------
% \PicFrameDot[#1](#2,#3)[(#4,#5)]
\def\PicFrameDot{\kframetrue\kdottrue\@ifnextchar[{\Axes@@}{\Axes@@[1]}}
\def\endPicFrameDot{\end{picture}}
%===============================================
% \PicDot(C)環境
%===============================================
% \PicDotC[#1](#2,#3)
\def\PicDotC{\kdottrue\@ifnextchar[{\AxesC@}{\AxesC@[1]}}
\def\endPicDotC{\end{picture}}
%-----------------------------------------------
% \PicDot[#1](#2,#3)[(#4,#5)]
\def\PicDot{\kdottrue\@ifnextchar[{\Axes@@}{\Axes@@[1]}}
\def\endPicDot{\end{picture}}
%===============================================
% \PicFrameGrid(C)環境
%===============================================
% \PicFrameGridC[#1](#2,#3)
\def\PicFrameGridC{\kframetrue\kgridtrue\@ifnextchar[{\AxesC@}{\AxesC@[1]}}
\def\endPicFrameGridC{\end{picture}}
%-----------------------------------------------
% \PicFrameGrid[#1](#2,#3)[(#4,#5)]
\def\PicFrameGrid{\kframetrue\kgridtrue\@ifnextchar[{\Axes@@}{\Axes@@[1]}}
\def\endPicFrameGrid{\end{picture}}
%===============================================
% \PicGrid(C)環境
%===============================================
% \PicGridC[#1](#2,#3)
\def\PicGridC{\kgridtrue\@ifnextchar[{\AxesC@}{\AxesC@[1]}}
\def\endPicGridC{\end{picture}}
%-----------------------------------------------
% \PicGrid[#1](#2,#3)[(#4,#5)]
\def\PicGrid{\kgridtrue\@ifnextchar[{\Axes@@}{\Axes@@[1]}}
\def\endPicGrid{\end{picture}}


%===============================================
% \AxesFrameScale(C)環境
%===============================================
% \AxesFrameScaleC[#1](#2,#3)
\def\AxesFrameScaleC{\kframetrue\kscaletrue\AxesC}
\def\endAxesFrameScaleC{\end{picture}}
%-----------------------------------------------
% \AxesFrameScale[#1](#2,#3)[(#4,#5)]
\def\AxesFrameScale{\kframetrue\kscaletrue\Axes}
\def\endAxesFrameScale{\end{picture}}
%===============================================
% \AxesScale環境
%===============================================
% \AxesScaleC[#1](#2,#3)
\def\AxesScaleC{\kscaletrue\AxesC}
\def\endAxesScaleC{\end{picture}}
%-----------------------------------------------
% \AxesScale[#1](#2,#3)[(#4,#5)]
\def\AxesScale{\kscaletrue\Axes}
\def\endAxesScale{\end{picture}}
%===============================================
% \AxesFrameDot(C)環境
%===============================================
% \AxesFrameDotC[#1](#2,#3)
\def\AxesFrameDotC{\kframetrue\kdottrue\AxesC}
\def\endAxesFrameDotC{\end{picture}}
%-----------------------------------------------
% \AxesFrameDot[#1](#2,#3)[(#4,#5)]
\def\AxesFrameDot{\kframetrue\kdottrue\Axes}
\def\endAxesFrameDot{\end{picture}}
%===============================================
% \AxesDot(C)環境
%===============================================
% \AxesDotC[#1](#2,#3)
\def\AxesDotC{\kdottrue\AxesC}
\def\endAxesDotC{\end{picture}}
%-----------------------------------------------
% \AxesDot[#1](#2,#3)[(#4,#5)]
\def\AxesDot{\kdottrue\Axes}
\def\endAxesDot{\end{picture}}
%===============================================
% \AxesFrameGrid(C)環境
%===============================================
% \AxesFrameGridC[#1](#2,#3)
\def\AxesFrameGridC{\kframetrue\kgridtrue\AxesC}
\def\endAxesFrameGridC{\end{picture}}
%-----------------------------------------------
% \AxesFrameGrid[#1](#2,#3)[(#4,#5)]
\def\AxesFrameGrid{\kframetrue\kgridtrue\Axes}
\def\endAxesFrameGrid{\end{picture}}
%===============================================
% \AxesGrid(C)環境
%===============================================
% \AxesGridC[#1](#2,#3)
\def\AxesGridC{\kgridtrue\AxesC}
\def\endAxesGridC{\end{picture}}
%-----------------------------------------------
% \AxesGrid[#1](#2,#3)[(#4,#5)]
\def\AxesGrid{\kgridtrue\Axes}
\def\endAxesGrid{\end{picture}}
%===============================================
% \AxesFrame(C)環境
%===============================================
% \AxesFrameC[#1](#2,#3)
\def\AxesFrameC{\kframetrue\AxesC}
\def\endAxesFrameC{\end{picture}}
%-----------------------------------------------
% \AxesFrame[#1](#2,#3)[(#4,#5)]
\def\AxesFrame{\kframetrue\Axes}
\def\endAxesFrame{\end{picture}}


%===============================================
% \Pic(C),\Axes(C)環境
%===============================================
% \PicC[#1](#2,#3)
% \AxesC[#1](#2,#3)
% 中心が原点になるように自動計算、後は\Picと同じ
\def\PicC{\AxesC@[1]}
\def\AxesC{\kaxestrue\@ifnextchar[{\AxesC@}{\AxesC@[1]}}
\def\AxesC@[#1]#2{\@AxesC[#1]#2}
\def\@AxesC[#1](#2,#3){\@killglue%
	\@PicCalcCenter(#2,#3)(\!!x,\!!y)
	\@Axes[#1](#2,#3)(\!!x,\!!y)
\ignorespaces}% End of \@AxesC
\def\endPicC{\end{picture}}
\def\endAxesC{\end{picture}}
%-----------------------------------------------
% \Pic(#1,#2)[(#3,#4)]
% \Axes[#1](#2,#3)[(#4,#5)]
\def\Pic(#1){\@ifnextchar({\@Axes[1](#1)}{\@Axes[1](#1)(0,0)}}
\def\Axes{\kaxestrue\@ifnextchar[{\Axes@@}{\Axes@@[1]}}
\def\Axes@@[#1]#2{\Axes@[#1]#2}
\def\Axes@[#1](#2){\@ifnextchar({\@Axes[#1](#2)}{\@Axes[#1](#2)(0,0)}}
\def\endPic{\end{picture}}
\def\endAxes{\end{picture}}

%-----------------------------------------------
% 環境を定義
% picture環境と同時に座標軸も設定
\def\@Axes[#1](#2,#3)(#4,#5){%
	\@KFrameAxes(#2,#3)(#4,#5)
	\begin{picture}(#2,#3)(#4,#5)
	\ifkdraw% 20090607start
		\kdottrue
	\fi% 20090607end
	\ifkaxes
		\@KAxes(#2,#3)(#4,#5)
	\fi
	\ifkframe
		\@KFrame(#2,#3)(#4,#5)
	\fi
	\WSeperate{#1}\!Ka\!Kax\@Dummy
	\ifkscale
	% 20120813 Start
		\ifdim #3\p@=\z@% y軸なし
			\@KScale(\!Ka,0)(0,0)
		\else
			\@KScale(\!Ka,\!Ka)(0,0)
		\fi
		\ifdim #2\p@=\z@% x軸なし
			\@KScale(0,\!Ka)(0,0)
		\else
			\@KScale(\!Ka,\!Ka)(0,0)
		\fi
	% 20120813 End
	\fi
	\ifx\!Kax\empty\else
		\ifkdot\else
			\ifkgrid\else
				% 20120813 Start
				\ifdim #3\p@=\z@% y軸なし
					\KScaleNumberZerotrue
					\@KScaleNumber(\!Kax,0)(\!Kax,0)
				\else
					\@KScaleNumber(\!Kax,\!Kax)(\!Kax,\!Kax)
				\fi
				\ifdim #2\p@=\z@% x軸なし
					\KScaleNumberZerotrue
					\@KScaleNumber(0,\!Kax)(0,\!Kax)
				\else
					\@KScaleNumber(\!Kax,\!Kax)(\!Kax,\!Kax)
				\fi
				% 20120813 End
			\fi
		\fi
	\fi
	\ifkgrid
%		\@KGridDot[\!Ka](#2,#3)(#4,#5)
		\@KGridDot[#1](#2,#3)(#4,#5)
	\fi
	\ifkdot
%		\@KGridDot[\!Ka](#2,#3)(#4,#5)
		\@KGridDot[#1](#2,#3)(#4,#5)
	\fi
}% End of \@Axes

\def\AxesLabelX{$x$}
\def\AxesLabelY{$y$}
%===============================================
%
% x-y軸を作る
%
%	\KAxes(#1,#2)(#3,#4)
%       #1:横の大きさ
%       #2:縦の大きさ
%       #3:左下のｘ座標
%       #4:左下のｙ座標
%
%===============================================
\def\KAxes(#1){\@ifnextchar({\@KAxes(#1)}{\@KAxes(#1)(0,0)}}

\def\@KAxes(#1,#2)(#3,#4){%
	% ｘ軸、ｙ軸
	\Add{#1}{#3}\Kx
	\Add{#2}{#4}\Ky

% 20120814 変更Start
	\edef\!!Kx{#1}% #1,#2のままだと値が変わるので代入
	\edef\!!Ky{#2}
	{\allinethickness{\KAxesLen}
		\ifdim #1\p@>\z@% x軸の線を引く
% 20191231 ksty226 Start
		    \ifknoaxes
				\put(#3,0){\line(1,0){#1}}
			\else
				\ifknoaxesX
					\put(#3,0){\line(1,0){#1}}
				\else
					\put(#3,0){\vector(1,0){#1}}
				\fi
			\fi
		\fi

		\ifdim #2\p@>\z@% y軸の線を引く
		    \ifknoaxes
				\put(0,#4){\line(0,1){#2}}
			\else
				\ifknoaxesY
					\put(0,#4){\line(0,1){#2}}
				\else
					\put(0,#4){\vector(0,1){#2}}
				\fi
			\fi
		\fi}% End of {}
% 20191231 ksty226 End

	\ifkaxesnolabel\else% \kaxesnolabelfalse ならば
		\ifkaxeslabelO\else% \kaxeslabelOfalse ならば
			\ifdim\!!Kx\p@>\z@% xの字を書く
				\KAxesLabelSep=3mm
				\KAxesLabel(\Kx,0){bl}{l}{\AxesLabelX}
			\fi
			\ifdim\!!Ky\p@>\z@% yの字を書く
				\KAxesLabelSep=3mm
				\KAxesLabel(0,\Ky){l}{tl}{\AxesLabelY}
			\fi
		\fi
		\ifkaxeslabelXY\else% \kaxeslabelXYfalse ならば
			\ifdim\!!Kx\p@>\z@% \!!Kxが正
				\ifdim\!!Ky\p@>\z@% \!!Kyも正
					\KAxesLabelSep=2.3mm
					\KAxesLabel(0,0){bl}{}{\footnotesize\rm O}
				\fi
			\fi
			\ifdim\!!Ky\p@>\z@% \!!Kyが正
				\ifdim\!!Kx\p@>\z@% \!!Kxも正
					\KAxesLabelSep=2.3mm
					\KAxesLabel(0,0){bl}{}{\footnotesize\rm O}
				\fi
			\fi
		\fi
	\fi
	\kaxesfalse
}% End of \KAxes
% 20120814 変更End

% 20110505 Start
% 20110802 Start
%===============================================
%
% 環境内に全体x-y軸を作る
%
%	\KAxesAuto[]
%
%===============================================
\def\KAxesAuto{\@ifnextchar[{\@KAxesAuto}{\@KAxesAuto[]}}%

\def\@KAxesAuto[#1]{\@killglue
	\@ifundefined{color}{}{\KMaskingtrue}
	\def\!Dummy{#1}
	\edef\!O{rb}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){rb}{}{\footnotesize\rm O}\fi
	\edef\!O{br}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){rb}{}{\footnotesize\rm O}\fi
	\edef\!O{rt}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){rt}{}{\footnotesize\rm O}\fi
	\edef\!O{tr}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){rt}{}{\footnotesize\rm O}\fi
	\edef\!O{lt}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){lt}{}{\footnotesize\rm O}\fi
	\edef\!O{tl}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){lt}{}{\footnotesize\rm O}\fi
	\edef\!O{lb}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){lb}{}{\footnotesize\rm O}\fi
	\edef\!O{bl}\ifx\!Dummy\!O\kaxeslabelXYtrue\KAxesLabelSep=2.3mm\KAxesLabel(0,0){lb}{}{\footnotesize\rm O}\fi
	
	\Sub\@KFrameRight\@KFrameLeft\!Kx
	\Sub\@KFrameTop\@KFrameBottom\!Ky
	\@KAxes(\!Kx,\!Ky)(\@KFrameLeft,\@KFrameBottom)
	\kaxeslabelXYfalse
	\KMaskingfalse
}% End of\@KAxesAuto


%===============================================
%
% x-y軸にラベルをつける
%
%	\KAxesLabel(#1,#2)#3#4#5
%       (#1,#2):おく座標(基準点)
%       #3:基準点からの方向
%       #4:おく位置
%       #5:おく文字
%
%   基準点からの距離は \KAxesLabelSepで指定しておく
%
%===============================================
\def\KAxesLabel(#1,#2)#3#4#5{%
	  \@KLenCalc{\KAxesLabelSep}{\@KAbsSep}
	  \!direction{#3}{\@KAbsSep}(\!Kx,\!Ky)%
	  \@KPointName(#1,#2)(\!Kx,\!Ky){#4}{#5}
}% End of \KAxesLabel


\def\KScaleDirectionX{0}
\def\KScaleDirectionY{0}
%===============================================
%
% x-y軸に目盛りを入れる
%
%	\KScale(#1,#2)[(#3,#4)]
%       #1:小目盛りをx軸の間隔(0で入れない)
%       #2:小目盛りをy軸の間隔(0で入れない)
%       #3:大目盛りをx軸の間隔(0で入れない)
%       #4:大目盛りをy軸の間隔(0で入れない)
%           ・\@KFrameAxesで定義されていることが必要(KPic.styの環境ならOK)
%           ・#3,#4は省略可能
%           ・小目盛りの長さは\KSmallScaleLen=0.5mm
%           ・大目盛りの長さは\KLargeScaleLen=1mm
%
%===============================================
\def\KScale(#1){\@ifnextchar({\@KScale(#1)}{\@KScale(#1)(0,0)}}

\def\@KScale(#1,#2)(#3,#4){%
	\@KLenCalc{\KSmallScaleLen}{\@KAbsSepSP}
	\ifdim \KScaleDirectionX\p@>\z@
		\def\@KAbsSepSM{0}
	\else
		\Mul{\@KAbsSepSP}{-1}{\@KAbsSepSM}
	\fi
	\ifdim \KScaleDirectionX\p@<\z@
		\def\@KAbsSepSP{0}
	\fi

	\@KLenCalc{\KLargeScaleLen}{\@KAbsSepLP}
	\ifdim \KScaleDirectionX\p@>\z@
		\def\@KAbsSepLM{0}
	\else
		\Mul{\@KAbsSepLP}{-1}{\@KAbsSepLM}
	\fi
	\ifdim \KScaleDirectionX\p@<\z@
		\def\@KAbsSepLP{0}
	\fi

	\ifdim #1\p@>\z@% x軸に引く
		% y軸平行＋側
		\def\!Kt{#1}
		\def\@KLargePoint{#3}
		\@whiledim\!Kt\p@<\@KFrameRight\p@\do{%
			\ifdim\!Kt\p@=\@KLargePoint\p@
				\put(\!Kt,0){\path(0,\@KAbsSepLP)(0,\@KAbsSepLM)}
				\Add\@KLargePoint{#3}\@KLargePoint
			\else
				\put(\!Kt,0){\path(0,\@KAbsSepSP)(0,\@KAbsSepSM)}
			\fi
			\Add\!Kt{#1}\!Kt
		}% End of \do
		% y軸平行−側
		\def\!Kt{#1}
		\Mul\!Kt{-1}\!Kt
		\def\@KLargePoint{#3}
		\Mul\@KLargePoint{-1}\@KLargePoint
		\@whiledim\!Kt\p@>\@KFrameLeft\p@\do{%
			\ifdim\!Kt\p@=\@KLargePoint\p@
				\put(\!Kt,0){\path(0,\@KAbsSepLP)(0,\@KAbsSepLM)}
				\Sub\@KLargePoint{#3}\@KLargePoint
			\else
				\put(\!Kt,0){\path(0,\@KAbsSepSP)(0,\@KAbsSepSM)}
			\fi
			\Sub\!Kt{#1}\!Kt
		}% End of \do
	    % 20120813 Start yの大きさが0の場合、y軸が描かれないから目盛りをふる
		\ifdim #2\p@=\z@
			\ifdim #3\p@=\z@
				\put(0,0){\path(0,\@KAbsSepSP)(0,\@KAbsSepSM)}
			\else
				\put(0,0){\path(0,\@KAbsSepLP)(0,\@KAbsSepLM)}
			\fi
		\fi
		% 20120813 End
	\fi

	\@KLenCalc{\KSmallScaleLen}{\@KAbsSepSP}
	\ifdim \KScaleDirectionY\p@>\z@
		\def\@KAbsSepSM{0}
	\else
		\Mul{\@KAbsSepSP}{-1}{\@KAbsSepSM}
	\fi
	\ifdim \KScaleDirectionY\p@<\z@
		\def\@KAbsSepSP{0}
	\fi

	\@KLenCalc{\KLargeScaleLen}{\@KAbsSepLP}
	\ifdim \KScaleDirectionY\p@>\z@
		\def\@KAbsSepLM{0}
	\else
		\Mul{\@KAbsSepLP}{-1}{\@KAbsSepLM}
	\fi
	\ifdim \KScaleDirectionY\p@<\z@
		\def\@KAbsSepLP{0}
	\fi

	\ifdim #2\p@>\z@% y軸に引く
		% x軸平行＋側
		\def\!Kt{#2}
		\def\@KLargePoint{#4}
		\@whiledim\!Kt\p@<\@KFrameTop\p@\do{%
			\ifdim\!Kt\p@=\@KLargePoint\p@
				\put(0,\!Kt){\path(\@KAbsSepLP,0)(\@KAbsSepLM,0)}
				\Add\@KLargePoint{#4}\@KLargePoint
			\else
				\put(0,\!Kt){\path(\@KAbsSepSP,0)(\@KAbsSepSM,0)}
			\fi
			\Add\!Kt{#2}\!Kt
		}% End of \do
		% x軸平行−側
		\def\!Kt{#2}
		\Mul\!Kt{-1}\!Kt
		\def\@KLargePoint{#4}
		\Mul\@KLargePoint{-1}\@KLargePoint
		\@whiledim\!Kt\p@>\@KFrameBottom\p@\do{%
			\ifdim\!Kt\p@=\@KLargePoint\p@
				\put(0,\!Kt){\path(\@KAbsSepLP,0)(\@KAbsSepLM,0)}
				\Sub\@KLargePoint{#4}\@KLargePoint
			\else
				\put(0,\!Kt){\path(\@KAbsSepSP,0)(\@KAbsSepSM,0)}
			\fi
			\Sub\!Kt{#2}\!Kt
		}% End of \do
	    % 20120813 Start xの大きさが0の場合、x軸が描かれないから目盛りをふる
		\ifdim #1\p@=\z@
			\ifdim #4\p@=\z@
				\put(0,0){\path(\@KAbsSepSP,0)(\@KAbsSepSM,0)}
			\else
				\put(0,0){\path(\@KAbsSepLP,0)(\@KAbsSepLM,0)}
			\fi
		\fi
		% 20120813 End
	\fi
	\kscalefalse
}% End of \@KScale


\def\KScaleNumberDirectionX{b}
\def\KScaleNumberDirectionY{l}
\def\KScaleNumberWordTypeX{}% 2000.05.30追加
\def\KScaleNumberWordTypeY{}% 2000.05.30追加
\newif\ifkSNRadian % \kSNRadiantrueで孤度表示% 20100609 Ver.2.00
\newif\ifkSNDegree % \kSNDegreetrueで度数表示
\newif\ifKScaleNumberZero % \ifKScaleNumberZeroで原点の変わりに数字のゼロを表示する 20120813作成
% ======== 20100609 ver.2.00 Start ==================
% 以下は、eclarith.styに定義してあるのでそのまま活用
%% \Pi is a greek letter.
%\def\Piq{0.78539816}
%\def\Pih{1.57079633}
%\def\Pie{3.14159265}
%\def\Pii{6.28318531}
%
% ここで、新たにπに関する定数を定義（直接数値を貼り付けてもかまわない）
\def\Pit{1.04719755}% Third 1/3
\def\Pif{0.62831853}% Fifth 1/5
\def\Pis{0.52359877}% Sixth 1/6
% ======== 20100609 ver.2.00 End==================

%===============================================
%
% x-y軸の目盛りに数字を入れる
%
%	\KScaleNumber[(#1,#2)][(#3,#4)]
%       #1:x軸に振る数字の初期値(プラス方向でマイナスは同等とする)
%       #2:y軸に振る数字の初期値(プラス方向でマイナスは同等とする)
%       #3:目盛りの数字のx軸の間隔
%       #4:目盛りの数字のy軸の間隔
%           ・\@KFrameAxesで定義されていることが必要(\Pic環境ならOK)
%           ・#1 or #2 がゼロの時は数字を入れない
%           ・(#1,#2)は省略可能、省略時の初期値は共に1、
%             ただし、(#3,#4)を省略しないときは省略不可
%           ・(#3,#4)は省略可能、(#3,#4)省略時の初期値は(#1,#2)
%           ・文字を置く方向は\KScaleNumberDirectionX(初期値はb)
%                             \KScaleNumberDirectionY(初期値はl)
%             に入っている。
%           ・文字の大きさは\KScaleNumberWordTypeX(初期値は{})
%                             \KScaleNumberWordTypeY(初期値は{})
%             に入っている。
%           ・距離は\WordSepをそのまま使用
%
%===============================================
\def\KScaleNumber{\@ifstar{\KScaleNumberZerotrue\KScaleNumber@@@}{\KScaleNumber@@@}}
\def\KScaleNumber@@@{\@ifnextchar({\KScaleNumber@@}{\KScaleNumber@@(1,1)}}
\def\KScaleNumber@@(#1){\KScaleNumber@(#1)}
\def\KScaleNumber@(#1){\@ifnextchar({\@KScaleNumber(#1)}{\@KScaleNumber(#1)(#1)}}

\def\@KScaleNumber(#1,#2)(#3,#4){%
  \ifdim #1\p@>\z@% x軸に引く
    \WSeperate{\KScaleNumberDirectionX}\!Ka\!Kb\!Kc
    \@KLenCalc{\WordSep}{\@KAbsSep}
    \!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
    % y軸平行＋側
    \def\@KScaleNumberTmp{#1}
    \KRoundTest{#1}{\!Kend}
    \def\!Kt{#3}
    \@whiledim\!Kt\p@<\@KFrameRight\p@\do{%
      \KRound{\@KScaleNumberTmp}{\!Kend}{\!!Kt}
      \KScaleNumberType{\!!Kt}{\!!Kt}
      \expandafter\@KPointName(\!Kt,0)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeX\!!Kt}
      \Add\!Kt{#3}\!Kt
      \Add\@KScaleNumberTmp{#1}\@KScaleNumberTmp
    }% End of \do
    % y軸平行−側
    \def\@KScaleNumberTmp{#1}
    \Mul\@KScaleNumberTmp{-1}\@KScaleNumberTmp
    \KRoundTest{#1}{\!Kend}
    \def\!Kt{#3}
    \Mul\!Kt{-1}\!Kt
    \@whiledim\!Kt\p@>\@KFrameLeft\p@\do{%
      \KRound{\@KScaleNumberTmp}{\!Kend}{\!!Kt}
      \KScaleNumberType{\!!Kt}{\!!Kt}
      \expandafter\@KPointName(\!Kt,0)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeX\!!Kt}
      \Sub\!Kt{#3}\!Kt
      \Sub\@KScaleNumberTmp{#1}\@KScaleNumberTmp
    }% End of \do
	  % 20120813 Start *が付いていてyの大きさがゼロだと原点に0を描く
	  \ifKScaleNumberZero
		\ifdim #2\p@=\z@
			\KScaleNumberType{0}{\!!Kt}
			\expandafter\@KPointName(0,0)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeX\!!Kt}
		\fi
	  \fi
	  % 20120813 End
  \fi
  \ifdim #2\p@>\z@% y軸に引く
    \WSeperate{\KScaleNumberDirectionY}\!Ka\!Kb\!Kc
    \@KLenCalc{\WordSep}{\@KAbsSep}
    \!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
    % x軸平行＋側
    \def\@KScaleNumberTmp{#2}
    \KRoundTest{#2}{\!Kend}
    \def\!Kt{#4}
    \@whiledim\!Kt\p@<\@KFrameTop\p@\do{%
      \KRound{\@KScaleNumberTmp}{\!Kend}{\!!Kt}
      \KScaleNumberType{\!!Kt}{\!!Kt}
      \expandafter\@KPointName(0,\!Kt)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeY\!!Kt}
      \Add\!Kt{#4}\!Kt
      \Add\@KScaleNumberTmp{#2}\@KScaleNumberTmp
    }% End of \do
    % x軸平行−側
    \def\@KScaleNumberTmp{#2}
    \Mul\@KScaleNumberTmp{-1}\@KScaleNumberTmp
    \KRoundTest{#2}{\!Kend}
    \def\!Kt{#4}
    \Mul\!Kt{-1}\!Kt
    \@whiledim\!Kt\p@>\@KFrameBottom\p@\do{%
      \KRound{\@KScaleNumberTmp}{\!Kend}{\!!Kt}
      \KScaleNumberType{\!!Kt}{\!!Kt}
      \expandafter\@KPointName(0,\!Kt)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeY\!!Kt}
      \Sub\!Kt{#4}\!Kt
      \Sub\@KScaleNumberTmp{#2}\@KScaleNumberTmp
      }% End of \do
	  % 20120813 Start *が付いていてxの大きさがゼロだと原点に0を描く
	  \ifKScaleNumberZero
	    \ifdim #1\p@=\z@
		  \KScaleNumberType{0}{\!!Kt}
          \expandafter\@KPointName(0,0)(\!Kx,\!Ky){\!Kb}{\KScaleNumberWordTypeY\!!Kt}
	    \fi
	  \fi
	  % 20120813 End
	\fi
\KScaleNumberZerofalse
}% End of \@KScaleNumber


%　ここを変更
% ======== 20100609 ver.2.00 Start ==================
%
% x-y軸の目盛りに入れる数字の種類に変換
%
%	\KScaleNumberType#1#2
%       #1:数値の入力
%       #2:数値の出力
%
\def\KScaleNumberType#1#2{%
  \ifkSNDegree% 度数表示
    \edef\!!Kt{${#1}^{\circ}$}
  \else
    \ifkSNRadian% 弧度法表示
	  \ifdim #1\p@=\z@ % #1が0？
		\edef\!!Kt{$0$}
	  \else
		\ifdim #1\p@<\z@ % #1がマイナス？
			\Mul{#1}{-1}{\!!KtC}
		\else
			\edef\!!KtC{#1}
		\fi

		\edef\!!KtA{180}
		\edef\!!KtB{180}

		\ifdim \!!KtC\p@>\!!KtA\p@ % #1が大きい？
          \edef\!!KtA{\!!KtC}
		\else
          \edef\!!KtB{\!!KtC}
		\fi
		% ユークリットの互除法
		\Floor{\!!KtA}{\!!KtB}{\!!KtC}{\!!KtD} % \!!KtAを\!!KtBで割った商が\!!KtC　余りが\!!KtD
		\@whiledim\!!KtD\p@>\z@\do{% 余りがゼロになるまで
          \edef\!!KtA{\!!KtB} % 割る数を元へ
          \edef\!!KtB{\!!KtD} % あまりを割る数へ
          \Floor{\!!KtA}{\!!KtB}{\!!KtC}{\!!KtD} % \!!KtAを\!!KtBで割った商が\!!KtC　余りが\!!KtD
		}% End of \do

		\Div{#1}{\!!KtB}{\!!KtA} % 分子
		\def\!!KtC{}
		% 負の場合の処理
		\ifdim #1\p@<\z@ % #1がマイナス？
          \Mul{\!!KtA}{-1}{\!!KtA}
          \def\!!KtC{-}
		\fi
		\KRound{\!!KtA}{0}{\!!KtA} % 小数点を除く

		\Div{180}{\!!KtB}{\!!KtB} % 分母
		\ifdim \!!KtB\p@=1\p@ % 分母が1？
	      \ifdim \!!KtA\p@=1\p@ % 分子が1？
            \edef\!!Kt{$\!!KtC\pi$}
          \else
            \edef\!!Kt{$\!!KtC{\!!KtA}\pi$}
          \fi
		\else
          \KRound{\!!KtB}{0}{\!!KtB} % 小数点を除く
  		  \ifdim \!!KtA\p@=1\p@ % 分子が1？
			\edef\!!Kt{$\displaystyle\!!KtC\frac{\pi}{\!!KtB}$}
          \else
			\edef\!!Kt{$\displaystyle\!!KtC\frac{\!!KtA}{\!!KtB}\pi$}
		  \fi
        \fi
      \fi
    \else
      \edef\!!Kt{$#1$}
	\fi
  \fi
  \let#2\!!Kt
}% End of \KScaleNumberType
% ======== 20100609 ver.2.00 End ==================


% 20101103 New
\def\kdotpoint{\circle*{0.01}}% \KDotの点の大きさ

\def\kdotinterval#1#2{% x,yともに同じ点の個数のときはこれ１回でＯＫ
  \def\!kdotUnitX{#1}% 単位
  \def\!kdotUnitY{#1}% 単位
  \def\!kdotIncreaseX{#2}% 単位の中の点の個数
  \def\!kdotIncreaseY{#2}% 単位の中の点の個数
  \Div{#1}{#2}\!kdotintervalX% KDotの横方向の間隔の初期値
  \Div{#1}{#2}\!kdotintervalY% KDotの縦方向の間隔の初期値
}

\def\kdotintervalX#1#2{% x軸と平行な点線のだけ
  \def\!kdotUnitX{#1}% 単位
  \def\!kdotIncreaseX{#2}% 単位の中の点の個数
  \Div{#1}{#2}\!kdotintervalX% KDotの横方向の間隔の初期値
}
\def\kdotintervalY#1#2{% y軸と平行な点線のだけ
  \def\!kdotUnitY{#1}% 単位
  \def\!kdotIncreaseY{#2}% 単位の中の点の個数
  \Div{#1}{#2}\!kdotintervalY% KDotの縦方向の間隔の初期値
}
\kdotintervalX{1}{6}% 初期値は１単位に６個
\kdotintervalY{1}{6}% 初期値は１単位に６個
%===============================================
% 実際にFrameを書くマクロ
%===============================================
%    枠の太さは\FrameLenで設定、初期値\FrameLen=0.8pt(\thickness)
\def\@KFrame(#1,#2)(#3,#4){\@killglue%
	\@KFrameAxes(#1,#2)(#3,#4)
	{\allinethickness{\FrameLen}\put(#3,#4){\framebox(#1,#2){}}}
	\kframefalse
    \ifkgrid\kframetrue\fi
    \ifkdot\kframetrue\fi
\ignorespaces}% End of \@KFrame


%===============================================
%
%	\KDot[点線の間隔](横の大きさ,縦の大きさ)(左下のｘ座標,左下のｙ座標)
%        横x，縦yの方眼紙を表示する
%        \dottedlineを使用して点線を書く
%
%===============================================
\def\KDot{\kdottrue\@ifnextchar[{\KGridDot@@}{\KGridDot@@[1]}}
%===============================================
%
%	\KGrid[線の間隔](横の大きさ,縦の大きさ)(左下のｘ座標,左下のｙ座標)
%        横x，縦yの方眼紙または、格子を表示する
%        \Pathを使用して点線を書く
%
%===============================================
\def\KGrid{\kgridtrue\@ifnextchar[{\KGridDot@@}{\KGridDot@@[1]}}
%===============================================
%
%	\@KGridDot[点線の間隔](横の大きさ,縦の大きさ)(左下のｘ座標,左下のｙ座標)
%        横x，縦yの方眼紙または、格子を表示する
%
%===============================================
\def\KGridDot@@[#1]#2{\KGridDot@[#1]#2}
\def\KGridDot@[#1](#2){\@ifnextchar({\@KGridDot[#1](#2)}{\@KGridDot[#1](#2)(0,0)}}
\def\@KGridDot[#1](#2,#3)(#4,#5){%
  \WSeperate{#1}\!Ka\!Kb\!Kc% new #1を分解し,2つならxとyを別個に表示
  \ifx\!Kb\empty
    \let\!Kb\!Ka
  \fi
  \ifkframe
    \@KFrame(#2,#3)(#4,#5)% 枠を描く
  \fi
% 20101103start
  \ifdim \!Ka\p@>\z@% 0でなければ
    % y軸平行＋側
    \let\!Kt\!Ka
    \def\!Kend{#4}
    \Add\!Kend{#2}\!Kend
    \@whiledim\!Kt\p@<\!Kend\p@\do{%
      \ifkdot\put(\!Kt,0){\@KGridDotSubY{#3}{#5}}\fi
      \ifkgrid\put(\!Kt,#5){\path(0,0)(0,#3)}\fi% 実線時の処理
      \Add\!Kt\!Ka\!Kt
    }% End of \do
    \ifkframe\else% 点線の右枠
      \ifdim\!Kt\p@=\!Kend\p@
        \ifkdot\put(\!Kt,0){\@KGridDotSubY{#3}{#5}}\fi
        \ifkgrid\put(\!Kt,#5){\path(0,0)(0,#3)}\fi% 実線時の処理
      \fi
    \fi
    % y軸平行−側
    \def\!Kt{0}
    \def\!Kend{#4}
    \@whiledim\!Kt\p@>\!Kend\p@\do{%
      \ifkdot\put(\!Kt,0){\@KGridDotSubY{#3}{#5}}\fi
      \ifkgrid\put(\!Kt,#5){\path(0,0)(0,#3)}\fi% 実線時の処理
      \Sub\!Kt\!Ka\!Kt
    }% End of \do
    \ifkframe\else% 点線の左枠
      \ifdim\!Kt\p@=\!Kend\p@
        \ifkdot\put(\!Kt,0){\@KGridDotSubY{#3}{#5}}\fi
        \ifkgrid\put(\!Kt,#5){\path(0,0)(0,#3)}\fi% 実線時の処理
      \fi
    \fi
% 20101115Start x軸平行の値に0を入れるをエラーするのを修正
  \fi% End of dim
  \ifdim \!Kb\p@>\z@% 0でなければ
% 20101115End
    % x軸平行＋側
    \let\!Kt\!Kb
    \def\!Kend{#5}
    \Add\!Kend{#3}\!Kend
    \@whiledim\!Kt\p@<\!Kend\p@\do{%
      \ifkdot\put(0,\!Kt){\@KGridDotSubX{#2}{#4}}\fi
      \ifkgrid\put(#4,\!Kt){\path(0,0)(#2,0)}\fi% 実線時の処理
      \Add\!Kt\!Kb\!Kt
    }% End of \do
    \ifkframe\else% 点線の上枠
      \ifdim\!Kt\p@=\!Kend\p@
        \ifkdot\put(0,\!Kt){\@KGridDotSubX{#2}{#4}}\fi
        \ifkgrid\put(#4,\!Kt){\path(0,0)(#2,0)}\fi% 実線時の処理
      \fi
    \fi
    % x軸平行−側
    \def\!Kt{0}
    \def\!Kend{#5}
    \@whiledim\!Kt\p@>\!Kend\p@\do{%
      \ifkdot\put(0,\!Kt){\@KGridDotSubX{#2}{#4}}\fi
      \ifkgrid\put(#4,\!Kt){\path(0,0)(#2,0)}\fi% 実線時の処理
      \Sub\!Kt\!Kb\!Kt
    }% End of \do
    \ifkframe\else% 点線の下枠
      \ifdim\!Kt\p@=\!Kend\p@
        \ifkdot\put(0,\!Kt){\@KGridDotSubX{#2}{#4}}\fi
        \ifkgrid\put(#4,\!Kt){\path(0,0)(#2,0)}\fi% 実線時の処理
      \fi%  End of ifdim
    \fi% End of ifkframe

  \fi% End of dim
  \kgridfalse
  \kdotfalse
  \kframefalse
}% End of \@KGridDot

\def\@KGridDotSubY#1#2{%
  % プラス方向
  \def\!!Kend{#1}
  \Add\!!Kend{#2}\!!Kend
  \def\!!Kt{0}
  \def\!!Kcoordinates{0}
  \def\!!Kcount{0}
  \Mul\!kdotintervalY{1}\!!kdotinterval
  \Mul\!kdotUnitY{1}\!!kdotUnit
  \@whiledim\!!Kt\p@<\!!Kend\p@\do{\@KGridDotSubSub{0}{\!!Kt}{\!kdotIncreaseY}}
  \ifdim\!!Kt\p@=\!!Kend\p@
    \put(0,\!!Kt){\makebox(0,0){\kdotpoint}}
  \fi
  % マイナス方向
  \def\!!Kend{#2}
  \def\!!Kt{0}
  \def\!!Kcoordinates{0}
  \def\!!Kcount{0}
  \Mul\!kdotintervalY{-1}\!!kdotinterval
  \Mul\!kdotUnitY{-1}\!!kdotUnit
  \@whiledim\!!Kt\p@>\!!Kend\p@\do{\@KGridDotSubSub{0}{\!!Kt}{\!kdotIncreaseY}}
  \ifdim\!!Kt\p@=\!!Kend\p@
    \put(0,\!!Kt){\makebox(0,0){\kdotpoint}}
  \fi
}% @KGridDotSubY

\def\@KGridDotSubX#1#2{%
  % プラス方向
  \def\!!Kend{#1}
  \Add\!!Kend{#2}\!!Kend
  \def\!!Kt{0}
  \def\!!Kcoordinates{0}
  \def\!!Kcount{0}
  \Mul\!kdotintervalX{1}\!!kdotinterval
  \Mul\!kdotUnitX{1}\!!kdotUnit
  \@whiledim\!!Kt\p@<\!!Kend\p@\do{\@KGridDotSubSub{\!!Kt}{0}{\!kdotIncreaseX}}
  \ifdim\!!Kt\p@=\!!Kend\p@% 最後の点
    \put(\!!Kt,0){\makebox(0,0){\kdotpoint}}
  \fi
  % マイナス方向
  \def\!!Kend{#2}
  \def\!!Kt{0}
  \def\!!Kcoordinates{0}
  \def\!!Kcount{0}
  \Mul\!kdotintervalX{-1}\!!kdotinterval
  \Mul\!kdotUnitX{-1}\!!kdotUnit
  \@whiledim\!!Kt\p@>\!!Kend\p@\do{\@KGridDotSubSub{\!!Kt}{0}{\!kdotIncreaseX}}
  \ifdim\!!Kt\p@=\!!Kend\p@% 最後の点
    \put(\!!Kt,0){\makebox(0,0){\kdotpoint}}
  \fi
}% @KGridDotSubX

\def\@KGridDotSubSub#1#2#3{%
    \put(#1,#2){\makebox(0,0){\kdotpoint}}
    \Add\!!Kt\!!kdotinterval\!!Kt
    \Add\!!Kcount{1}\!!Kcount
    \def\!kdotIncrease{#3}
    \ifdim\!!Kcount\p@=\!kdotIncrease\p@% 誤差を単位ごとに補正する
      \Add\!!Kcoordinates\!!kdotUnit\!!Kcoordinates
      \let\!!Kt\!!Kcoordinates
      \def\!!Kcount{0}
    \fi
}% End of \@KGridDotSubSub
% 20101103 End

%===============================================
%
%	\KRoundTest{数字}{小数第何位まであったか出力}
%
\def\KRoundTest#1#2{%
	\edef\@KIntger{#1}
	\def\@KRoundTmp{.}
	\def\@KRTmp{0}
	% \expandafterの入れまくり(マクロの八街P21)
	\expandafter\@tfor\expandafter\loop@knode\expandafter:%
	\expandafter=\@KIntger\do{%
		\if@KDecimal% 小数点以下
			\Add\@KRTmp{1}\@KRTmp
		\else
			\if\@KRoundTmp\loop@knode
				\@KDecimaltrue
			\fi
		\fi
	}% End of \do
	\@KDecimalfalse
	\let#2=\@KRTmp
}% End of \KRoundTest


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      node座標を処理するマクロ
%
%===============================================
% １．座標を定義するメインマクロ
%===============================================
% nodeの座標点に点を置くかどうかの判断
%
\newif\ifbulletnode % \bulletnodeでアスタリスクがあるかないかの判断
%\newif\ifkbullet % \kbullettrueで無条件に点をつける 20100613作成したが思うように動かないので保留
%
% node座標を定義するマクロは最後はここへ来る。
% ここでの作業は、
%   １．条件によって、座標に点を打つ
%   ２．座標を定義する(\@Knodeで処理)
%   ３．座標の指定された場所に文字等を表示する(\@KPointNameで処理)
%
\def\@nodeMain(#1,#2)#3[#4][#5]{\@killglue%
	\ifbulletnode
		\@KLenCalc{\KBullet}{\@KAbsSep}
		\put(#1,#2){$\circle*{\@KAbsSep}$}
%	\else % 20100613作成 Start 失敗
%	  \ifkbullet
%		\@KLenCalc{\KBullet}{\@KAbsSep}
%		\put(#1,#2){$\circle*{\@KAbsSep}$}
%	  \fi　% 20100613作成 End
	\fi
	\edef\!Kt{(#1,#2)#3}
	\expandafter\@Knode\!Kt% 座標を定義
	\WSeperate{#5}\!Ka\!Kb\!Kc% #5を分解
	\@KLenCalc{\WordSep}{\@KAbsSep}
	\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
	\expandafter\@KPointName(#1,#2)(\!Kx,\!Ky){\!Kb}{#4}
	\bulletnodefalse
\ignorespaces}% End of \@nodeMain

% 20110507 Start
%-----------------------------------------------
% 座標を定義時に自動で定義名や座標が入る命令
% Eclarithパッケージで定義されている \node で表示部分を除いたもの
\def\@KSameCnode#1#2#3{%
	\def\KSame{#3}
	\def\Cnode{$(#1,\KSpace#2)$}
	\def\CnodeName{#3$(#1,\KSpace#2)$}
	\def\CnodeX{$#1$}
	\def\CnodeY{$#2$}
}% \@KSameCnode End
% 20110507 End


\newif\ifKMasking % \KMaskingで文字のしたの線を消す
%-----------------------------------------------
% node座標を定義する部分
% Eclarithパッケージで定義されている \node で表示部分を除いたもの
\def\@Knode(#1,#2)#3{\@killglue\@namedef{N?#3}{(#1,#2)}\ignorespaces}
%-----------------------------------------------
% node座標の回りに文字等を定義する
% このマクロはnode以外のマクロで多く使われている
\def\@KPointName(#1,#2)(#3,#4)#5#6{\@killglue%
	\ifKMasking
		\@Masking{#1}{#2}{#3}{#4}{#5}{#6}
	\fi
	\put(#1,#2){\put(#3,#4){\makebox(0,0)[#5]{#6}}}
\ignorespaces}% End of \@KPointName

% 20120107 Start
\def\@Masking#1#2#3#4#5#6{\@killglue%
	\if{#6}\empty\else
		\setbox0=\hbox{#6}
		\@KLenCalc{\wd0}{\!@Kw}
		\@KLenCalc{\ht0}{\!@Kh}
		\@KLenCalc{\dp0}{\!@Kd}
		\Add\!@Kh\!@Kd\!@Kh
		\Div\!@Kw{2}\!@Kx
		\Mul\!@Kx{-1}\!@Kx
		\Div\!@Kh{2}\!@Ky
		\Mul\!@Ky{-1}\!@Ky
		\KSeperate{#5}{\K!a}{\K!b}{\K!c}% #5を分解
		\edef\!O{l}\if\K!a\!O\def\!@Kx{0}\fi
		\edef\!O{r}\if\K!a\!O\Add\!@Kx\!@Kx\!@Kx\fi
		\edef\!O{t}\if\K!a\!O\Add\!@Ky\!@Ky\!@Ky\fi
		\edef\!O{b}\if\K!a\!O\def\!@Ky{0}\fi
		\edef\!O{l}\if\K!b\!O\def\!@Kx{0}\fi
		\edef\!O{r}\if\K!b\!O\Add\!@Kx\!@Kx\!@Kx\fi
		\edef\!O{t}\if\K!b\!O\Add\!@Ky\!@Ky\!@Ky\fi
		\edef\!O{b}\if\K!b\!O\def\!@Ky{0}\fi
% 20120119 Start
		\@KLenCalc{\KMaskingPadding}{\!@Padding}
		\Sub\!@Kx\!@Padding\!@Kx
		\Sub\!@Ky\!@Padding\!@Ky
		\Add\!@Kw\!@Padding\!@Kw
		\Add\!@Kw\!@Padding\!@Kw
		\Add\!@Kh\!@Padding\!@Kh
		\Add\!@Kh\!@Padding\!@Kh
% 20120119 End
		\put(#1,#2){\put(#3,#4){\put(\!@Kx,\!@Ky){\whiten\path(0,0)(\!@Kw,0)(\!@Kw,\!@Kh)(0,\!@Kh)(0,0)}}}
		\put(#1,#2){\put(#3,#4){\put(\!@Kx,\!@Ky){\color{white}{\thicklines\path(0,0)(\!@Kw,0)(\!@Kw,\!@Kh)(0,\!@Kh)(0,0)}}}}
	\fi
\ignorespaces}% End of \@Masking
%20120107 End


%===============================================
% ２．直交座標で定義するマクロ
%===============================================
%
% \Knode[*][#1](#2,#3){#4}[#5][#6_1,#6_2]
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:nodeで定義された名前
%         (省略した場合は原点を基準とする)
%       #2:x座標
%       #3:y座標
%       #4:内部処理する座標名
%       #5:表示する座標名(省略可)
%       #6_1:#5を表示する方向(省略可)
%       #6_2:#5を表示する位置(省略可)
%
\def\Knode{\@ifstar{\bulletnodetrue\Knode@@}{\Knode@@}}

\def\Knode@@{%
	\@ifnextchar({\@KnodeI@@}{\@KnodeII@@@}
}% End of Knode@@

\def\@KnodeI@@(#1,#2)#3{\@killglue%
	\@ifnextchar[{\@KnodeI@(#1,#2)#3}{\@@Knode(#1,#2)#3[][]}
}% End of \@KnodeI@@
\def\@KnodeI@(#1,#2)#3[#4]{\@killglue%
	\@ifnextchar[{\@@Knode(#1,#2)#3[#4]}{\@@Knode(#1,#2)#3[#4][]}
}% End of \@KnodeI@

\def\@KnodeII@@@#1(#2,#3)#4{\@killglue%
	\@ifnextchar[{\@KnodeII@@#1(#2,#3)#4}{\@KnodeII@#1(#2,#3)#4[][]}
}% End of \@KnodeII@@@
\def\@KnodeII@@#1(#2,#3)#4[#5]{\@killglue%
	\@ifnextchar[{\@KnodeII@#1(#2,#3)#4[#5]}{\@KnodeII@#1(#2,#3)#4[#5][]}
}% End of \@KnodeII@@
\def\@KnodeII@#1(#2,#3)#4[#5][#6]{\@killglue
	\edef\!Kt{(#2,#3)}
	\edef\!Kt{\!Kt\@nameuse{N?#1}}
	\@KVecAdd\!Kt\!Kt
	\expandafter\@@Knode\!Kt{#4}[#5][#6]
\ignorespaces}% End of \@nodeKnode

\def\@@Knode(#1,#2)#3[#4][#5]{\@killglue
	\@KSameCnode{#1}{#2}{#3}
	\expandafter\@nodeMain(#1,#2){#3}[#4][#5]
\ignorespaces}% End of \@KnodeMain


%20110504 Start
%===============================================
% ２−１．\Knodeで四隅を定義するマクロ
%===============================================
%
% \KnodeLB[*]{#1}[#2][#3_1,#3_2]・・・左下の座標を#1へ入れる
% \KnodeRB[*]{#1}[#2][#3_1,#3_2]・・・右下の座標を#1へ入れる
% \KnodeRT[*]{#1}[#2][#3_1,#3_2]・・・右上の座標を#1へ入れる
% \KnodeLT[*]{#1}[#2][#3_1,#3_2]・・・左上の座標を#1へ入れる
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:内部処理する座標名
%       #2:表示する座標名(省略可)
%       #3_1:#5を表示する方向(省略可)
%       #3_2:#5を表示する位置(省略可)
%
\def\KnodeLB{\def\!x{\@KFrameLeft}\def\!y{\@KFrameBottom}\@ifstar{\bulletnodetrue\@KnodeCornerI@@}{\@KnodeCornerI@@}}
\def\KnodeRB{\def\!x{\@KFrameRight}\def\!y{\@KFrameBottom}\@ifstar{\bulletnodetrue\@KnodeCornerI@@}{\@KnodeCornerI@@}}
\def\KnodeRT{\def\!x{\@KFrameRight}\def\!y{\@KFrameTop}\@ifstar{\bulletnodetrue\@KnodeCornerI@@}{\@KnodeCornerI@@}}
\def\KnodeLT{\def\!x{\@KFrameLeft}\def\!y{\@KFrameTop}\@ifstar{\bulletnodetrue\@KnodeCornerI@@}{\@KnodeCornerI@@}}

\def\@KnodeCornerI@@#1{\@killglue%
	\@ifnextchar[{\@KnodeCornerI@#1}{\@@KnodeCorner#1[][]}
}% End of \@KnodeCornerI@@
\def\@KnodeCornerI@#1[#2]{\@killglue%
	\@ifnextchar[{\@@KnodeCorner#1[#2]}{\@@KnodeCorner#1[#2][]}
}% End of \@KnodeCornerI@

\def\@@KnodeCorner#1[#2][#3]{\@killglue
	\@KSameCnode{\!x}{\!y}{#1}
	\expandafter\@nodeMain(\!x,\!y){#1}[#2][#3]
\ignorespaces}% End of \@@KnodeCorner
% 20110504 End

%20120104 Start
%===============================================
% ２−１−１．\Knodeで四隅を一括で定義するマクロ
%===============================================
%
% \KnodeCorner{#1,#2,#3,#4}
%       #1:左下の座標名
%       #2:右下の座標名
%       #3:右上の座標名
%       #4:左上の座標名
%
\def\KnodeCorner#1{\@killglue%
	\WSeperateFour{#1}{\K!a}{\K!b}{\K!c}{\K!d}% #1を分解
	\expandafter\@nodeMain(\@KFrameLeft,\@KFrameBottom){\K!a}[][]
	\expandafter\@nodeMain(\@KFrameRight,\@KFrameBottom){\K!b}[][]
	\expandafter\@nodeMain(\@KFrameRight,\@KFrameTop){\K!c}[][]
	\expandafter\@nodeMain(\@KFrameLeft,\@KFrameTop){\K!d}[][]
\ignorespaces}% End of \@@KnodeCorner
% 20120104 End

%\Tnode[*]{A}(1,2)[2]{B}[表示文字][文字位置]
%\Tnode[*]{A}{X}[2]{B}[表示文字][文字位置]
%===============================================
% ？．ある点を基準に点を拡大縮小した点を定義するマクロ
%      20050919
%===============================================
%
% \Tnode[*]{#1}[(#2,#3)][#4]{#5}[#6][#7_1,#7_2]
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:nodeで定義された名前
%       #2:基準となる点のx座標(省略した場合は原点)
%       #3:基準となる点のy座標(省略した場合は原点)
%		#4:倍率、負の数を入れると反対側に表示(省略不可)
%       #5:内部処理する座標名
%       #6:表示する座標名(省略可)
%       #7_1:#6を表示する方向(省略可)
%       #7_2:#6を表示する位置(省略可)
%
% \Tnode[*]{#1}{#2}[#3]{#4}[#5][#6_1,#6_2]
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:nodeで定義された名前
%       #2:基準となる点でnodeで定義された名前(省略した場合は原点)
%		#3:倍率、負の数を入れると反対側に表示(省略不可)
%       #4:内部処理する座標名
%       #5:表示する座標名(省略可)
%       #6_1:#6を表示する方向(省略可)
%       #6_2:#6を表示する位置(省略可)
%

\def\Tnode{\@ifstar{\bulletnodetrue\Tnode@@}{\Tnode@@}}%

\def\Tnode@@#1{\@killglue%
	\@ifnextchar({\@TnodeI@@#1}{\@TnodeII@@@@#1}
}% End of Tnode@@

\def\@TnodeI@@#1(#2,#3)[#4]#5{\@killglue%
	\@ifnextchar[{\@TnodeI@#1(#2,#3)[#4]#5}{\@Tnode#1(#2,#3)[#4]#5[][]}
}% End of \@TnodeI@@
\def\@TnodeI@#1(#2,#3)[#4]#5[#6]{\@killglue%
	\@ifnextchar[{\@Tnode#1(#2,#3)[#4]#5[#6]}{\@Tnode#1(#2,#3)[#4]#5[#6][]}
}% End of \@TnodeI@

%(#2,#3)がない場合
\def\@TnodeII@@@@#1{\@killglue%
	\@ifnextchar[{\@TnodeIII@@@#1}{\@TnodeII@@#1}
}% End of \@KnodeII@@@@

%(#2,#3)がなく後に[#4]がある場合
\def\@TnodeIII@@@#1[#2]#3{\@killglue%
	\@ifnextchar[{\@TnodeIII@@#1[#2]#3}{\@Tnode#1(0,0)[#2]#3[][]}
}% End of \@KnodeII@@@

\def\@TnodeIII@@#1[#2]#3[#4]{\@killglue%
	\@ifnextchar[{\@Tnode#1(0,0)[#2]#3[#4]}{\@Tnode#1(0,0)[#2]#3[#4][]}
}% End of \@TnodeIII@@

%(#2,#3)がなく代わりに{#4}がある場合
\def\@TnodeII@@#1#2[#3]#4{\@killglue%
	\@ifnextchar[{\@TnodeII@#1#2[#3]#4}{\@@Tnode#1#2[#3]#4[][]}
}% End of \@TodeII@@

\def\@TnodeII@#1#2[#3]#4[#5]{\@killglue%
	\@ifnextchar[{\@@Tnode#1#2[#3]#4[#5]}{\@@Tnode#1#2[#3]#4[#5][]}
}% End of \@TodeII@

\def\@@Tnode#1#2[#3]#4[#5][#6]{\@killglue
	\edef\!Kt{\@nameuse{N?#1}\@nameuse{N?#2}}
	\@KVecSub\!Kt\!Kt
	\@SVecMul\!Kt{#3}\!Kt
	\edef\!Kt{\!Kt\@nameuse{N?#2}}
	\@KVecAdd\!Kt\!Kt
	\expandafter\@@Knode\!Kt{#4}[#5][#6]
\ignorespaces}% End of \@nodeTnode

\def\@Tnode#1(#2,#3)[#4]#5[#6][#7]{\@killglue
	\edef\!Kt{(#2,#3)}
	\edef\!Kt{\@nameuse{N?#1}\!Kt}
	\@KVecSub\!Kt\!Kt
	\@SVecMul\!Kt{#4}\!Kt
	\edef\!Kt{\!Kt(#2,#3)}
	\@KVecAdd\!Kt\!Kt
	\expandafter\@@Knode\!Kt{#5}[#6][#7]
\ignorespaces}% End of \@nodeTnode

%===============================================
% ３．平面を極座標で定義するマクロ
%===============================================
% Palor node
% 極座標で点を指定する。#1と#2以外は\Knodeと同じ
% ただし、角度はラジアンではなく，「度」で入力。その方が見た目がわかる
% 中心の度をP?#3で保存、\PAngleで使用可能
%
%\Pnode[*][(#1,#2)](#3,#4){#5}[#6][#7_1,#7_2]
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:仮の中心のｘ座標
%       #2:仮の中心のｙ座標
%         (この２つを省略した場合は原点が中心と考える)
%       #3:仮の中心からの長さ
%       #4:角度(°)
%       #5:内部処理する座標名
%       #6:表示する座標名(省略可)
%       #7_1:#6を表示する方向(省略可)
%       #7_2:#6を表示する位置(省略可)
%\Pnode[*][#1](#3,#4){#5}[#6][#7_1,#7_2]
%       #1:nodeで定義された名前
\def\Pnode{\@ifstar{\bulletnodetrue\Pnode@@}{\Pnode@@}}

\def\Pnode@@{%
	\@ifnextchar({\@PnodeI@@@}{\@PnodeII@@@}
}% End of Pnode@@

\def\@PnodeI@@@(#1){%
	\@ifnextchar({\@PnodeI@@(#1)}{\@PnodeI@@(0,0)(#1)}
}% End of \@PnodeI@@@
\def\@PnodeI@@(#1)(#2)#3{%
	\@ifnextchar[{\@PnodeI@(#1)(#2)#3}{\@Pnode(#1)(#2)#3[][]}
}% End of \@PnodeI@@
\def\@PnodeI@(#1)(#2)#3[#4]{%
	\@ifnextchar[{\@Pnode(#1)(#2)#3[#4]}{\@Pnode(#1)(#2)#3[#4][]}
}% End of \@PnodeI@

\def\@PnodeII@@@#1(#2)#3{%
	\@ifnextchar[{\@PnodeII@@#1(#2)#3}{\@PnodeII@#1(#2)#3[][]}
}% End of \@PnodeII@@@
\def\@PnodeII@@#1(#2)#3[#4]{%
	\@ifnextchar[{\@PnodeII@#1(#2)#3[#4]}{\@PnodeII@#1(#2)#3[#4][]}
}% End of \@PnodeII@@
\def\@PnodeII@#1(#2,#3)#4[#5][#6]{%
	\edef\!Kt{\@nameuse{N?#1}}
	\expandafter\@Pnode\!Kt(#2,#3){#4}[#5][#6]
}% End of \PnodeII@

\def\@Pnode(#1,#2)(#3,#4)#5[#6][#7]{%
	% 極座標を平面座標へ変換
	\KPoleToXY(#3,#4)(\@KDx,\@KDy)
	\Add\@KDx{#1}\@KDx
	\Add\@KDy{#2}\@KDy
	\@namedef{P?#5}{#4}
	\KVecRound(\@KDx,\@KDy)\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#5}
	\@nodeMain(\@KDx,\@KDy){#5}[#6][#7]
}% End of \@Pnode


%===============================================
% ４．空間座標で定義するマクロ
%===============================================
% Space node
%  空間座標を平面に変換して表示
%   後回し
%   1999.03.27再開
% \Snode[*][#1](#2,#3,#4){#5}[#6][#7_1,#7_1]
%        *:付けると座標の場所に$\bullet$(・)を置く
%       #1:nodeで定義された名前
%         (省略した場合は原点を基準とする)
%       #2:x座標
%       #3:y座標
%       #4:z座標
%       #5:内部処理する座標名
%       #6:表示する座標名(省略可)
%       #7_1:#5を表示する方向(省略可)
%       #7_2:#5を表示する位置(省略可)
\def\Snode{\@ifstar{\bulletnodetrue\Snode@@}{\Snode@@}}

\def\Snode@@{\@ifnextchar({\@SnodeI@@}{\@SnodeII@@@}}

\def\@SnodeI@@(#1,#2,#3)#4{\@killglue%
	\@ifnextchar[{\@SnodeI@(#1,#2,#3)#4}{\@@Snode(#1,#2,#3)#4[][]}
}% End of \@SnodeI@@
\def\@SnodeI@(#1,#2,#3)#4[#5]{\@killglue%
	\@ifnextchar[{\@@Snode(#1,#2,#3)#4[#5]}{\@@Snode(#1,#2,#3)#4[#5][]}
}% End of \@SnodeI@

\def\@SnodeII@@@#1(#2,#3,#4)#5{\@killglue%
	\@ifnextchar[{\@SnodeII@@#1(#2,#3,#4)#5}{\@SnodeII@#1(#2,#3,#4)#5[][]}
}% End of \@SnodeII@@@
\def\@SnodeII@@#1(#2,#3,#4)#5[#6]{\@killglue%
	\@ifnextchar[{\@SnodeII@#1(#2,#3,#4)#5[#6]}{\@SnodeII@#1(#2,#3,#4)#5[#6][]}
}% End of \@SnodeII@@

\def\@SnodeII@#1(#2,#3,#4)#5[#6][#7]{\@killglue
%	\edef\!Kt{(#2,#3)}
%	\edef\!Kt{\!Kt\@nameuse{N?#1}}
%	\@KVecAdd\!Kt\!Kt
%	\expandafter\@@Knode\!Kt{#4}[#5][#6]% ?
	\expandafter\@@Snode(#2,#3,#4){#5}[#6][#7]% ?
\ignorespaces}% End of \@SnodeII@

\def\@@Snode(#1,#2,#3)#4[#5][#6]{\@killglue
	\def\Cnode{$(#1,\KSpace#2,\KSpace#3)$}
	\def\CnodeName{#4$(#1,\KSpace#2,\KSpace#3)$}
	\obbase(-0.5,-0.375)(1,0)
	\KThreeTwo(#1,#2,#3)(\@KDx,\@KDy)% 平面に変換
% 20110505 Start
	\def\KSame{#4}
	\def\CnodeX{$\@KDx$}
	\def\CnodeY{$\@KDy$}
% 20110505 End
	\expandafter\@nodeMain(\@KDx,\@KDy){#4}[#5][#6]
\ignorespaces}% End of \@@Snode


%===============================================
% ５．node座標をもとに、内分点・外分点を定義する
%===============================================
\newif\if@KDivP % \@KDivP 内分か外分かの判断
%-----------------------------------------------
% Internally dividing point(内分点)
%	\Inode[*]{両端のnode座標}(内分する比){定義文字名}[文字][方向,文字位置]
%   定義済みの2点を内分する点を定義
\def\Inode{\@ifstar{\bulletnodetrue\IEnode@@}{\IEnode@@}}
%-----------------------------------------------
% Externally dividing point(外分点)
%	\Enode[*]{両端のnode座標}(外分する比){定義文字名}[文字][方向,文字位置]
%   定義済みの2点を外分する点を定義
\def\Enode{\@KDivPtrue\@ifstar{\bulletnodetrue\IEnode@@}{\IEnode@@}}


% 内分外分のサブマクロ
\def\IEnode@@#1(#2:#3)#4{%
	\@ifnextchar[{\IEnode@#1(#2:#3)#4}{\@IEnode#1(#2:#3)#4[][]}
}% End of \IEnode@@
\def\IEnode@#1(#2:#3)#4[#5]{%
	\@ifnextchar[{\@IEnode#1(#2:#3)#4[#5]}{\@IEnode#1(#2:#3)#4[#5][]}
}% End of \IEnode@@

\def\@IEnode#1(#2:#3)#4[#5][#6]{\@killglue%
	\KSeperate{#1}{\K!a}{\K!b}{\K!c}% #1を分解
	\edef\K!a{\@nameuse{N?\K!a}}
	\edef\K!b{\@nameuse{N?\K!b}}
	\@SVecMul\K!a{#3}\K!a
	\@SVecMul\K!b{#2}\K!b
	\if@KDivP% 外分点なら
		\@SVecMul\K!a{-1}\K!a
	\fi
	\@VecAdd\K!a\K!b\K!a% 分子
	\def\K!b{#3}
	\if@KDivP% 外分点なら
		\Mul\K!b{-1}\K!b
	\fi
	\Add{#2}\K!b\K!b% 分母
	\Div{1}\K!b\K!b% 逆数
	\@SVecMul\K!a\K!b\K!a
	\expandafter\KVecRound\K!a\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#4}
	\expandafter\@nodeMain\K!a{#4}[#5][#6]%
	\@KDivPfalse
\ignorespaces}% End of \@IEnode


%===============================================
% ６．node座標をもとに、三点を頂点とする三角形の重心を定義する
%===============================================
%
%	\Barycenter[*]{３点のnode座標}{定義文字名}[文字][方向,文字位置]
%   定義済みの３点を頂点とする三角形の重心を定義する
\def\Barycenter{\@ifstar{\bulletnodetrue\Barycenter@@}{\Barycenter@@}}

\def\Barycenter@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\Barycenter@{#1}{#2}}{\@Barycenter{#1}{#2}[][]}
}% End of \Barycenter@@
\def\Barycenter@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@Barycenter{#1}{#2}[#3]}{\@Barycenter{#1}{#2}[#3][]}
}% End of \Barycenter@

\def\@Barycenter#1#2[#3][#4]{\@killglue%
	\KSeperate{#1}{\K!a}{\K!b}{\K!c}% #1を分解
	\edef\K!a{\@nameuse{N?\K!a}}
	\edef\K!b{\@nameuse{N?\K!b}}
	\edef\K!c{\@nameuse{N?\K!c}}
	\@VecAdd\K!a\K!b\K!a% 分子
	\@VecAdd\K!a\K!c\K!a% 分子
	\@SVecMul\K!a{0.333333}\K!a
	\expandafter\KVecRound\K!a\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#2}
	\expandafter\@nodeMain\K!a{#2}[#3][#4]%
	\@KDivPfalse
\ignorespaces}% End of \@Barycenter


%===============================================
% ７．node座標をもとに、三点を頂点とする三角形の内心を定義する
%===============================================
%
%	\Incenter[*]{３点のnode座標}{定義文字名}[文字][方向,文字位置]
%   定義済みの３点を頂点とする三角形の内心を定義する
%
\def\Incenter{\@ifstar{\bulletnodetrue\Incenter@@}{\Incenter@@}}

\def\Incenter@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\Incenter@{#1}{#2}}{\@Incenter{#1}{#2}[][]}
}% End of \Incenter@@
\def\Incenter@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@Incenter{#1}{#2}[#3]}{\@Incenter{#1}{#2}[#3][]}
}% End of \Incenter@

\def\@Incenter#1#2[#3][#4]{\@killglue%
	\KSeperate{#1}{\K!a}{\K!b}{\K!c}% #1を分解
	\edef\K!a{\@nameuse{N?\K!a}}
	\edef\K!b{\@nameuse{N?\K!b}}
	\edef\K!c{\@nameuse{N?\K!c}}
	\@VecSub\K!b\K!a\K!bA%

	\edef\K!!{\K!b\K!c}%
	\expandafter\Distance\K!!\K!!% aを計算
	\@SVecMul\K!a\K!!\K!d
	\Add\K!!{0}\K!f

	\edef\K!!{\K!c\K!a}%
	\expandafter\Distance\K!!\K!!% bを計算
	\@SVecMul\K!b\K!!\K!e
	\@VecAdd\K!d\K!e\K!d%
	\Add\K!f\K!!\K!f

	\edef\K!!{\K!a\K!b}%
	\expandafter\Distance\K!!\K!!% cを計算
	\@SVecMul\K!c\K!!\K!e
	\@VecAdd\K!d\K!e\K!d%
	\Add\K!f\K!!\K!f

	\Div{1}\K!f\K!f% 逆数
	\@SVecMul\K!d\K!f\K!d
% 半径の計算
	\expandafter\KVecScalar\K!a(\@Ax,\@Ay)
	\expandafter\KVecScalar\K!b(\@Bx,\@By)
	\Mul\@Ax\@By\K!e
	\Mul\@Ay\@Bx\K!f
	\Sub\K!f\K!e\K!f% x1y2 - x2y1

	\expandafter\KVecScalar\K!bA(\@BAx,\@BAy)
	\expandafter\KVecScalar\K!d(\@Dx,\@Dy)
	\Mul\@BAy\@Dx\K!e
	\Add\K!f\K!e\K!f
	\Mul\@BAx\@Dy\K!e
	\Sub\K!f\K!e\K!f
	\ifdim \K!f\p@<\z@
		\Mul\K!f{-1}\K!f
	\fi
	\edef\K!!{\K!a\K!b}%
	\expandafter\Distance\K!!\K!e
	\Div\K!f\K!e\KRadius
	\Mul\KRadius{2}\KDiameter% 直径も計算しておく
	\expandafter\KVecRound\K!d\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#2}
	\expandafter\@nodeMain\K!d{#2}[#3][#4]%
\ignorespaces}% End of \@Incenter


%===============================================
% ８．node座標をもとに、三点を頂点とする三角形の外心を定義する
%===============================================
%
%	\Circumcenter[*]{３点のnode座標}{定義文字名}[文字][方向,文字位置]
%   定義済みの３点を頂点とする三角形の外心を定義する
%
\def\Circumcenter{\@ifstar{\bulletnodetrue\Circumcenter@@}{\Circumcenter@@}}

\def\Circumcenter@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\Circumcenter@{#1}{#2}}{\@Circumcenter{#1}{#2}[][]}
}% End of \Circumcenter@@
\def\Circumcenter@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@Circumcenter{#1}{#2}[#3]}{\@Circumcenter{#1}{#2}[#3][]}
}% End of \Circumcenter@

\def\@Circumcenter#1#2[#3][#4]{\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\edef\!Kc{\@nameuse{N?\!Kc}}

	\edef\!Kd{\!Ka\!Kb\!Kc}
	\expandafter\@CircumcenterSub\!Kd(\!KX,\!KY)\KRadius

	\Mul\KRadius{2}\KDiameter% 直径も計算しておく
	\edef\!Kt{(\!KX,\!KY)}%
	\expandafter\KVecRound\!Kt\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#2}
	\expandafter\@nodeMain\!Kt{#2}[#3][#4]%
\ignorespaces}% End of \@Circumcenter


%===============================================
%
%	\@CircumcenterSub(座標)(座標)(座標)(外心){半径}
%   ３つの点から外心と半径を計算する
%
\def\@CircumcenterSub(#1,#2)(#3,#4)(#5,#6)(#7,#8)#9{\@killglue%
	\edef\!Ka{(#1,#2)}
	\edef\!Kb{(#3,#4)}
	\edef\!Kc{(#5,#6)}

	\@VecSub\!Kb\!Ka\@VBA%
	\expandafter\KVecScalar\@VBA(\@BAx,\@BAy)
	\@VecSub\!Kc\!Ka\@VCA%
	\expandafter\KVecScalar\@VCA(\@CAx,\@CAy)

	\Mul\@BAx\@CAy\@DeltaA
	\Mul\@BAy\@CAx\@DeltaB
	\Sub\@DeltaA\@DeltaB\@Delta% デルタを計算
	\AbsSign\@Delta\@AbsDelta\Dummy
	\ifdim \@AbsDelta\p@<0.0001\p@% \@AbsDeltaが0.0001より小さければ
		\typeout{Circumcenter don't Calc}\stop%
	\fi
	\Mul\@BAy{-1}\@BAy
	\Mul\@CAx{-1}\@CAx

% 20111229 バク取り Start ver2.16
	\ifdim #1\p@=\z@
		\ifdim #2\p@=\z@
			\def\!Kd{0}
		\else
			\expandafter\Distance\!Ka(0,0)\!Kd%
		\fi
	\else
		\expandafter\Distance\!Ka(0,0)\!Kd%
	\fi
	\Mul\!Kd\!Kd\!Kd
	\ifdim #3\p@=\z@
		\ifdim #4\p@=\z@
			\def\!Kb{0}
		\else
			\expandafter\Distance\!Kb(0,0)\!Kb%
		\fi
	\else
		\expandafter\Distance\!Kb(0,0)\!Kb%
	\fi
	\Mul\!Kb\!Kb\!Kb
	\Sub\!Kb\!Kd\!Kb
	\ifdim #5\p@=\z@
		\ifdim #6\p@=\z@
			\def\!Kc{0}
		\else
			\expandafter\Distance\!Kc(0,0)\!Kc%
		\fi
	\else
			\expandafter\Distance\!Kc(0,0)\!Kc%
	\fi
% 20111229 バグ取り end
	\Mul\!Kc\!Kc\!Kc
	\Sub\!Kc\!Kd\!Kc

	\Mul\!Kb\@CAy\@CAy
	\Mul\!Kc\@BAy\@BAy
	\Add\@CAy\@BAy\!KX
	\Div\!KX\@Delta\!KX
	\Div\!KX{2}\!KX
	
	\Mul\!Kb\@CAx\@CAx
	\Mul\!Kc\@BAx\@BAx
	\Add\@CAx\@BAx\!KY
	\Div\!KY\@Delta\!KY
	\Div\!KY{2}\!KY
	
	\expandafter\Distance\!Ka(\!KX,\!KY)\KRadius% 半径を計算しておく
	\let#7=\!KX
	\let#8=\!KY
	\let#9=\KRadius
\ignorespaces}% End of \@CircumcenterSub


%===============================================
% ９．node座標をもとに、２点からの指定した距離の点を定義する
%===============================================
%
%	\TwoCirclesRight[*]{両端のnode座標}(両端からの距離){定義文字名}[文字][方向,文字位置]
%	\TwoCirclesLeft[*]{両端のnode座標}(両端からの距離){定義文字名}[文字][方向,文字位置]
%
\def\TwoCirclesRight{\@ifstar{\bulletnodetrue\TwoCircles@@}{\TwoCircles@@}}
\def\TwoCirclesLeft{\@KDivPtrue\@ifstar{\bulletnodetrue\TwoCircles@@}{\TwoCircles@@}}

\def\TwoCircles@@#1(#2,#3)#4{%
	\@ifnextchar[{\TwoCircles@#1(#2,#3)#4}{\@TwoCircles#1(#2,#3)#4[][]}
}% End of \TwoCircle@@
\def\TwoCircles@#1(#2,#3)#4[#5]{% 
	\@ifnextchar[{\@TwoCircles#1(#2,#3)#4[#5]}{\@TwoCircles#1(#2,#3)#4[#5][]}
}% End of \TwoCircle@

\def\@TwoCircles#1(#2,#3)#4[#5][#6]{\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\edef\!Kc{\@nameuse{N?\!Kc}}
	\@VecSub\!Ka\!Kb\!Kc

	\expandafter\KVecScalar\!Kb(\!KtSa,\!KtSb)
	\ifdim\!KtSa\p@=\z@
		\ifdim\!KtSb\p@=\z@
			\def\!Kb{0}
		\else
			\expandafter\Distance\!Kb(0,0)\!Kb%
			\Mul\!Kb\!Kb\!Kb
		\fi
	\else
		\expandafter\Distance\!Kb(0,0)\!Kb%
		\Mul\!Kb\!Kb\!Kb
	\fi

	\expandafter\KVecScalar\!Ka(\!KtSa,\!KtSb)
	\ifdim\!KtSa\p@=\z@
		\ifdim\!KtSb\p@=\z@
			\def\!Ka{0}
		\else
			\expandafter\Distance\!Ka(0,0)\!Ka%
			\Mul\!Ka\!Ka\!Ka
		\fi
	\else
		\expandafter\Distance\!Ka(0,0)\!Ka%
		\Mul\!Ka\!Ka\!Ka
	\fi
	\Sub\!Ka\!Kb\!Ka

	\Mul{#2}{#2}\!Kb
	\Sub\!Ka\!Kb\!Ka
	\Mul{#3}{#3}\!Kb
	\Add\!Ka\!Kb\!Kd

	\expandafter\KVecScalar\!Kc(\!KtLA,\!KtLB)
	\Mul\!KtSa{2}\!Ka
	\Mul\!Ka\!KtLB\!Ka
	\Mul\!Ka\!KtLB\!KX
	\Mul\!Ka\!KtLA\!KY
	\Mul\!KY{-1}\!KY
	\Mul\!KtSb{2}\!Ka
	\Mul\!Ka\!KtLA\!Ka
	\Mul\!Ka\!KtLB\!Kb
	\Sub\!KX\!Kb\!KX
	\Mul\!Ka\!KtLA\!Ka
	\Add\!KY\!Ka\!KY
	\Mul\!Kd\!KtLA\!Ka
	\Add\!KX\!Ka\!KX
	\Mul\!Kd\!KtLB\!Ka
	\Add\!KY\!Ka\!KY

	\ifdim\!KtLA\p@=\z@
		\ifdim\!KtLB\p@=\z@
			\def\!Kc{0}
		\else
			\expandafter\Distance\!Kc(0,0)\!Kc%
			\Mul\!Kc\!Kc\!Kc
		\fi
	\else
		\expandafter\Distance\!Kc(0,0)\!Kc%
		\Mul\!Kc\!Kc\!Kc
	\fi
	\Mul\!Kc{2}\!Kc
	\Div\!KX\!Kc\!KX
	\Div\!KY\!Kc\!KY
	%\!KX,\!KYが直交する点

	\edef\!KXY{(\!KX,\!KY)}
	\expandafter\Distance(\!KtSa,\!KtSb)(\!KX,\!KY)\!Kb%
	\Mul\!Kb\!Kb\!Kb
	\Mul{#2}{#2}\!Ka
	\Sub\!Ka\!Kb\!Ka
	\Sqroot\!Ka\!Ka

	\edef\@KAbsSep{\!Ka}
	\@KNintySep{#1}{\@KAbsSep}(\!Kx,\!Ky)
	\edef\!Ka{(\!Kx,\!Ky)}
	\@VecAdd\!KXY\!Ka\!KXY
	\expandafter\KVecRound\!KXY\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#4}
	\expandafter\@nodeMain\!KXY{#4}[#5][#6]
\ignorespaces}% End of \@TwoCircles


%===============================================
% 10．node座標をもとに、２点を通る直線と別の点からの垂線の交点を求め、定義する
%===============================================
%
%	\Perpendicularfoot[*]{直線上の２点の座標}{垂線上の点}{定義文字名}[文字][方向,文字位置]
%
\def\Perpendicularfoot{\@ifstar{\bulletnodetrue\Perpendicularfoot@@}{\Perpendicularfoot@@}}

\def\Perpendicularfoot@@#1#2#3{% #1#2#3が展開されるため、以下カッコ必要
	\@ifnextchar[{\Perpendicularfoot@{#1}{#2}{#3}}{\@Perpendicularfoot{#1}{#2}{#3}[][]}
}% End of \Perpendicularfoot@@
\def\Perpendicularfoot@#1#2#3[#4]{% #1#2#3が展開されるため、以下カッコ必要
	\@ifnextchar[{\@Perpendicularfoot{#1}{#2}{#3}[#4]}{\@Perpendicularfoot{#1}{#2}{#3}[#4][]}
}% End of \Perpendicularfoot@

\def\@Perpendicularfoot#1#2#3[#4][#5]{\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\@VecSub\!Ka\!Kb\!Kc

	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\edef\!Kd{\@nameuse{N?#2}}% 垂線上の点
	\expandafter\KVecScalar\!Kd(\!Kcx,\!Kcy)

	\expandafter\KVecScalar\!Kc(\!Kgx,\!Kgy)
	\ifdim\!Kgx\p@=\z@% x座標が一致
		\edef\!KXY{(\!Kax,\!Kcy)}
	\else
		\ifdim\!Kgy\p@=\z@% y座標が一致
			\edef\!KXY{(\!Kcx,\!Kay)}
		\else
			\Div\!Kgy\!Kgx\!Kg% ２直線の傾き
			\Div{1}\!Kg\!Kh% ２直線の傾きの逆数
			\Mul\!Kh{-1}\!Kh% マイナスを掛けて法線の傾きにした
			% xの分子
			\Mul\!Kax\!Kg\!Kb
			\Mul\!Kcx\!Kh\!Kc
			\Sub\!Kb\!Kc\!Kc
			\Add\!Kc\!Kcy\!Kc
			\Sub\!Kc\!Kay\!Kc
			% xの分母
			\Sub\!Kg\!Kh\!Kh
			% xを出す
			\Div\!Kc\!Kh\!KX
			% yを出す
			\Sub\!KX\!Kax\!KY
			\Mul\!KY\!Kg\!KY
			\Add\!KY\!Kay\!KY

			\edef\!KXY{(\!KX,\!KY)}
		\fi
	\fi

	\expandafter\KVecRound\!KXY\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#3}
	\expandafter\@nodeMain\!KXY{#3}[#4][#5]
\ignorespaces}% End of \@Perpendicularfoot


% 20110504 Start
%===============================================
% 11．直線とPic環境の境界の点を定義する
%===============================================
%
%	\KLineLeftEdge[*]{直線の傾き,ｙ切片}{定義文字名}[文字][方向,文字位置]・・・境界と直線の交点の左側
%	\KLineRightEdge[*]{直線の傾き,ｙ切片}{定義文字名}[文字][方向,文字位置]・・・境界と直線の交点の右側
%	\KLineBothEdge{直線の傾き,ｙ切片}{左側定義文字名,右側定義文字名}・・・境界と直線の交点の両方
%
\def\KLineBothEdge#1#2{\@killglue%
	\WSeperate{#1}{\!Kmm}{\!Knn}{\!Koo}% #1を分解
	\WSeperate{#2}{\!Kl}{\!Kr}{\!Koi}% #2を分解
	\KLineLeftEdge@@{\!Kmm,\!Knn}{\!Kl}%
	\KLineRightEdge@@{\!Kmm,\!Knn}{\!Kr}%
\ignorespaces}% End of \@KLineBothEdge

\def\KLineLeftEdge{\@ifstar{\bulletnodetrue\KLineLeftEdge@@}{\KLineLeftEdge@@}}

\def\KLineLeftEdge@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\KLineLeftEdge@{#1}{#2}}{\@KLineLeftEdge{#1}{#2}[][]}
}% End of \KLineLeftEdge@@
\def\KLineLeftEdge@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@KLineLeftEdge{#1}{#2}[#3]}{\@KLineLeftEdge{#1}{#2}[#3][]}
}% End of \Intersection@

\def\@KLineLeftEdge#1#2[#3][#4]{\@killglue%
	\WSeperate{#1}{\!Km}{\!Kn}{\!Ko}% #1を分解
	\ifdim\!Km\p@>\z@% 傾きが正
		\Sub\@KFrameBottom\!Kn\!Kx
		\Div\!Kx\!Km\!Kx
		\ifdim\!Kx\p@>\@KFrameLeft\p@ % \!Kxが\@KFrameLeftより大きいか
			\ifdim\!Kx\p@>\@KFrameRight\p@ % \!Kxが\@KFrameRightより大きいか
				\typeout{Out of Area!}\stop%
			\else
				\Add\@KFrameBottom{0}\!Ky
			\fi
		\else
			\Mul\!Km\@KFrameLeft\!Ky
			\Add\!Ky\!Kn\!Ky
			\ifdim\!Ky\p@>\@KFrameTop\p@ % \!Kyが\@KFrameToptより大きいか
				\typeout{Out of Area!}\stop%
			\fi
			\Add\@KFrameLeft{0}\!Kx
		\fi
	\else
		\ifdim\!Km\p@<\z@% 傾きが負
			\Sub\@KFrameTop\!Kn\!Kx
			\Div\!Kx\!Km\!Kx
			\ifdim\!Kx\p@>\@KFrameLeft\p@ % \!Kxが\@KFrameLeftより大きいか
				\ifdim\!Kx\p@>\@KFrameRight\p@ % \!Kxが\@KFrameRightより大きいか
					\typeout{Out of Area!}\stop%
				\else
					\Add\@KFrameTop{0}\!Ky
				\fi
			\else
				\Mul\!Km\@KFrameLeft\!Ky
				\Add\!Ky\!Kn\!Ky
				\ifdim\!Ky\p@<\@KFrameBottom\p@ % \!Kyが\@KFrameToptより大きいか
					\typeout{Out of Area!}\stop%
				\fi
				\Add\@KFrameLeft{0}\!Kx
			\fi
		\else % 残ったのは傾きが0
			\Add\@KFrameLeft{0}\!Kx
			\Add\!Kn{0}\!Ky
		\fi
	\fi

	\edef\!Kt{(\!Kx,\!Ky)}%
	\expandafter\KVecRound\!Kt\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#2}
	\expandafter\@nodeMain\!Kt{#2}[#3][#4]
\ignorespaces}% End of \@KLineLeftEdge


\def\KLineRightEdge{\@ifstar{\bulletnodetrue\KLineRightEdge@@}{\KLineRightEdge@@}}

\def\KLineRightEdge@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\KLineRightEdge@{#1}{#2}}{\@KLineRightEdge{#1}{#2}[][]}
}% End of \KLineRightEdge@@
\def\KLineRightEdge@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@KLineRightEdge{#1}{#2}[#3]}{\@KLineRightEdge{#1}{#2}[#3][]}
}% End of \Intersection@

\def\@KLineRightEdge#1#2[#3][#4]{\@killglue%
	\WSeperate{#1}{\!Km}{\!Kn}{\!Ko}% #1を分解
	\ifdim\!Km\p@>\z@% 傾きが正
		\Sub\@KFrameTop\!Kn\!Kx
		\Div\!Kx\!Km\!Kx
		\ifdim\!Kx\p@>\@KFrameLeft\p@ % \!Kxが\@KFrameLeftより大きいか
			\ifdim\!Kx\p@>\@KFrameRight\p@ % \!Kxが\@KFrameRightより大きいか
				\Mul\!Km\@KFrameRight\!Ky
				\Add\!Ky\!Kn\!Ky
				\ifdim\!Ky\p@<\@KFrameBottom\p@ % \!Kyが\@KFrameBottomより小さいか
					\typeout{Out of Area!}\stop%
				\fi
				\Add\@KFrameRight{0}\!Kx
			\else
				\Add\@KFrameTop{0}\!Ky
			\fi
		\else
			\ifdim\!Kx\p@<\@KFrameLeft\p@ % \!Kxが\@KFrameLeftより小さいか
				\typeout{Out of Area!}\stop%
			\else
				\Add\@KFrameTop{0}\!Ky
				\Add\@KFrameLeft{0}\!Kx
			\fi
		\fi
	\else
		\ifdim\!Km\p@<\z@% 傾きが負
			\Sub\@KFrameBottom\!Kn\!Kx
			\Div\!Kx\!Km\!Kx
			\ifdim\!Kx\p@<\@KFrameRight\p@ % \!Kxが\@KFrameRightより小さいか
				\ifdim\!Kx\p@<\@KFrameLeft\p@ % \!Kxが\@KFrameLeftより小さいか
					\typeout{Out of Area!}\stop%
				\else
					\Add\@KFrameBottom{0}\!Ky
				\fi
			\else
				\Mul\!Km\@KFrameRight\!Ky
				\Add\!Ky\!Kn\!Ky
				\ifdim\!Ky\p@>\@KFrameTop\p@ % \!Kyが\@KFrameToptより大きいか
					\typeout{Out of Area!}\stop%
				\fi
				\Add\@KFrameRight{0}\!Kx
			\fi
		\else % 残ったのは傾きが0
			\Add\@KFrameRight{0}\!Kx
			\Add\!Kn{0}\!Ky
		\fi
	\fi

	\edef\!Kt{(\!Kx,\!Ky)}%
	\expandafter\KVecRound\!Kt\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#2}
	\expandafter\@nodeMain\!Kt{#2}[#3][#4]
\ignorespaces}% End of \@KLineRightEdge
% 20110504 End


% 20120722 Start 改良
%===============================================
% 12．node座標をもとに、２直線の交点を求め、定義する
%===============================================
%
%	\Intersection[*]{２点の座標}{２点の座標}{定義文字名}[文字][方向,文字位置]
%
\def\Intersection{\@ifstar{\bulletnodetrue\Intersection@@}{\Intersection@@}}

\def\Intersection@@#1#2#3{% #1#2#3が展開されるため、以下カッコ必要
	\@ifnextchar[{\Intersection@{#1}{#2}{#3}}{\@Intersection{#1}{#2}{#3}[][]}
}% End of \Intersection@@
\def\Intersection@#1#2#3[#4]{% #1#2#3が展開されるため、以下カッコ必要
	\@ifnextchar[{\@Intersection{#1}{#2}{#3}[#4]}{\@Intersection{#1}{#2}{#3}[#4][]}
}% End of \Intersection@

\def\@Intersection#1#2#3[#4][#5]{\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}

	\KSeperate{#2}{\!Kd}{\!Ke}{\!Kf}% #2を分解
	\edef\!Kd{\@nameuse{N?\!Kd}}
	\edef\!Ke{\@nameuse{N?\!Ke}}

	\@@Intersection{\!Ka}{\!Kb}{\!Kd}{\!Ke}{#3}[#4][#5]
}% End of \@Intersection

%20120722 円の接線の交点を求めるため変更
\def\@@Intersection#1#2#3#4#5[#6][#7]{\@killglue%
	\edef\!Ka{#1}\edef\!Kb{#2}\edef\!Kd{#3}\edef\!Ke{#4}
	\@VecSub\!Ka\!Kb\!Kc
	\@VecSub\!Kd\!Ke\!Kf

	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\expandafter\KVecScalar\!Kd(\!Kcx,\!Kcy)
	
	\expandafter\KVecScalar\!Kc(\!Kgx,\!Kgy)
	\expandafter\KVecScalar\!Kf(\!Khx,\!Khy)
	\ifdim\!Kgx\p@=\z@% 初めの直線のx座標が一致
		\ifdim\!Khx\p@=\z@% 次の直線のx座標も一致
			\typeout{Parallel lines! Not of intersection point}\stop%
		\else
			\ifdim\!Khy\p@=\z@% 次の直線のy座標が一致
				\edef\!KXY{(\!Kax,\!Kcy)}
			\else
				\Div\!Khy\!Khx\!Kh% 次の直線の傾き(エラーしないはず)
				\Sub\!Kax\!Kcx\!KY
				\Mul\!Kh\!KY\!KY
				\Add\!KY\!Kcy\!KY
				\edef\!KXY{(\!Kax,\!KY)}
			\fi
		\fi
	\else
		\ifdim\!Kgy\p@=\z@% 初めの直線のy座標が一致
			\ifdim\!Khy\p@=\z@% 次の直線のy座標も一致
				\typeout{Parallel lines! Not of intersection point}\stop%
			\else
				\ifdim\!Khy\p@=\z@% 次の直線のx座標が一致
					\edef\!KXY{(\!Kcx,\!Kay)}
				\else
					\Div\!Khy\!Khx\!Kh% 次の直線の傾き
					\Sub\!Kay\!Kcy\!KX
					\Div\!KX\!Kh\!KX
					\Add\!KX\!Kcx\!KX
					\edef\!KXY{(\!KX,\!Kay)}
				\fi
			\fi
		\else
			\ifdim\!Khx\p@=\z@% 次の直線のx座標が一致
				\Div\!Kgy\!Kgx\!Kg% 次の直線の傾き(エラーしないはず)
				\Sub\!Kcx\!Kax\!KY
				\Mul\!Kg\!KY\!KY
				\Add\!KY\!Kay\!KY
				\edef\!KXY{(\!Kcx,\!KY)}
			\else
				\ifdim\!Khy\p@=\z@% 次の直線のy座標が一致
					\Div\!Kgy\!Kgx\!Kg% 次の直線の傾き
					\Sub\!Kcy\!Kay\!KX
					\Div\!KX\!Kg\!KX
					\Add\!KX\!Kax\!KX
					\edef\!KXY{(\!KX,\!Kcy)}
				\else
					\Div\!Kgy\!Kgx\!Kg% 初めの直線の傾き
					\Div\!Khy\!Khx\!Kh% 次の直線の傾き
					\ifdim\!Kg\p@=\!Kh\p@% ２直線の傾き同じ
						\typeout{Parallel lines! Not of intersection point}\stop%
					\else
						% xの分子
						\Mul\!Kax\!Kg\!Kb
						\Mul\!Kcx\!Kh\!Kc
						\Sub\!Kb\!Kc\!Kc
						\Add\!Kc\!Kcy\!Kc
						\Sub\!Kc\!Kay\!Kc
						% xの分母
						\Sub\!Kg\!Kh\!Kh
						% xを出す
						\Div\!Kc\!Kh\!KX
						% yを出す
						\Sub\!KX\!Kax\!KY
						\Mul\!KY\!Kg\!KY
						\Add\!KY\!Kay\!KY
						\edef\!KXY{(\!KX,\!KY)}
					\fi
				\fi
			\fi
		\fi
	\fi

	\expandafter\KVecRound\!KXY\KFigure(\@@KDx,\@@KDy)
	\@KSameCnode{\@@KDx}{\@@KDy}{#5}
	\expandafter\@nodeMain\!KXY{#5}[#6][#7]
\ignorespaces}% End of \@@Intersection


% 20120722 Start
%===============================================
% 13．円周上の２点の接線の交点を求め、定義する
%===============================================
%
%	\IntersectionOfTangent[*]{中心,接点，接点の(座標名)}{定義文字名}[文字][方向,文字位置]
%
\def\IntersectionOfTangent{\@ifstar{\bulletnodetrue\IntersectionOfTangent@@}{\IntersectionOfTangent@@}}

\def\IntersectionOfTangent@@#1#2{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\IntersectionOfTangent@{#1}{#2}}{\@IntersectionOfTangent{#1}{#2}[][]}
}% End of \IntersectionOfTangent@@
\def\IntersectionOfTangent@#1#2[#3]{% #1#2が展開されるため、以下カッコ必要
	\@ifnextchar[{\@IntersectionOfTangent{#1}{#2}[#3]}{\@IntersectionOfTangent{#1}{#2}[#3][]}
}% End of \IntersectionOfTangent@

\def\@IntersectionOfTangent#1#2[#3][#4]{\@killglue%
	\WSeperate{#1}{\!Ko}{\!Ka}{\!Kd}% #1を分解
	\edef\!Ko{\@nameuse{N?\!Ko}}% 中心O
	\edef\!Ka{\@nameuse{N?\!Ka}}% 接点A
	\edef\!Kd{\@nameuse{N?\!Kd}}% 接点B
	\@VecSub\!Ka\!Ko\!Kc% 直線OAの傾き
	\@VecSub\!Kd\!Ko\!Kf% 直線OBの傾き

	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\expandafter\KVecScalar\!Kc(\!Kcx,\!Kcy)
	\expandafter\KVecScalar\!Kd(\!Kdx,\!Kdy)
	\expandafter\KVecScalar\!Kf(\!Kfx,\!Kfy)

	\ifdim\!Kcy\p@=\z@% OAがx軸平行
		\Add\!Kay{1}\!Kcy
		\edef\!Kb{(\!Kax,\!Kcy)}
	\else
		\Div\!Kcx\!Kcy\!Kcy
		\Mul\!Kcy{-1}\!Kcy
		\Add\!Kay\!Kcy\!Kcy
		\Add\!Kax{1}\!Kcx
		\edef\!Kb{(\!Kcx,\!Kcy)}
	\fi

	\ifdim\!Kfy\p@=\z@% OBがx軸平行
		\Add\!Kdy{1}\!Kfy
		\edef\!Ke{(\!Kdx,\!Kfy)}
	\else
		\Div\!Kfx\!Kfy\!Kfy
		\Mul\!Kfy{-1}\!Kfy
		\Add\!Kdy\!Kfy\!Kfy
		\Add\!Kdx{1}\!Kfx
		\edef\!Ke{(\!Kfx,\!Kfy)}
	\fi

	\@@Intersection{\!Ka}{\!Kb}{\!Kd}{\!Ke}{#2}[#3][#4]% 後は２直線の交点を求めるのに任せた！
\ignorespaces}% End of \@IntersectionOfTangent




% 20110809 Start
\newif\iflinenode% 軸上に小目盛りを引くため
%===============================================
% 14．定義した点から座標軸への点線・破線を描く
%===============================================
% 
%  \PointDotX[*][点線の間隔]{#2}[#3][#4]・・・#2の点からx軸へ点線を引き、x軸に小目盛りの線を表示する（点線の間隔を省略すると0.1が入る)
%  \PointDotY[*][点線の間隔]{#2}[#3][#4]・・・#2の点からy軸へ点線を引き、y軸に小目盛りの線を表示する（点線の間隔を省略すると0.1が入る)
%  \PointDotXY[*][点線の間隔]{#2}[#3]・・・定義した点からx軸とy軸へ点線を引く（点線の間隔を省略すると0.1が入る)、#3には\Cnodeを入れるとx軸とy軸に数字を入れることしか出来ない
%  \PointDashX[*][stretch]{破線の間隔}{#3}[#4][#5]・・・#3の点からx軸へ破線を引き、x軸に小目盛りの線を表示する
%  \PointDashY[*][stretch]{破線の間隔}{#3}[#4][#5]・・・#3の点からy軸へ破線を引き、軸に小目盛りの線を表示する
%  \PointDashXY[*][stretch]{破線の間隔}{#3}・・・#3の点からx軸,y軸へ破線を引き、軸に小目盛りの線を表示する
%
\def\PointDotXY{\@ifstar{\linenodetrue\PointDotXY@@@}{\PointDotXY@@@}}
\def\PointDotXY@@@{\@ifnextchar[{\PointDotXY@@}{\PointDotXY@@[0.1]}}
\def\PointDotXY@@[#1]#2{\@ifnextchar[{\@PointDotXY[#1]#2}{\@PointDotXY[#1]#2[]}}
\def\@PointDotXY[#1]#2[#3]{%
	\edef\!Ka{\@nameuse{N?#2}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dottedline{#1}(\!Kax,\!Kay)(\!Kax,0)}
	\put(0,0){\dottedline{#1}(\!Kax,\!Kay)(0,\!Kay)}
	\@@PointCommon{\!Kax}{\!Kay}
	\@PointCommonXY{\!Kax}{\!Kay}
}% End of \@PointDotXY

\def\PointDashXY{\@ifstar{\linenodetrue\PointDashXY@}{\PointDashXY@}}
\def\PointDashXY@{\@ifnextchar[{\@PointDashXY}{\@PointDashXY[1]}}
%\def\PointDashXY@@[#1]#2#3{\@ifnextchar[{\PointDashXY@[#1]{#2}{#3}}{\PointDashXY@[#1]{#2}{#3}[]}}
%\def\PointDashXY@[#1]#2#3[#4]{\@ifnextchar[{\@PointDashXY[#1]{#2}{#3}[#4]}{\@PointDashXY[#1]{#2}{#3}[#4][]}}
%\def\@PointDashXY[#1]#2#3[#4][#5]{%
\def\@PointDashXY[#1]#2#3{%
	\edef\!Ka{\@nameuse{N?#3}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dashline[#1]{#2}(\!Kax,\!Kay)(\!Kax,0)}
	\put(0,0){\dashline[#1]{#2}(\!Kax,\!Kay)(0,\!Kay)}
	\@@PointCommon{\!Kax}{\!Kay}
	\@PointCommonXY{\!Kax}{\!Kay}
}% End of \@PointDashXY

\def\@PointCommonXY#1#2{%
	\KVecRound(#1,#2)\KFigure(\@@KDx,\@@KDy)
	\@KLenCalc{\WordSep}{\@KAbsSep}
	\ifdim\!Kax\p@>\z@
		\!direction{l}{\@KAbsSep}(\!Kx,\!Ky)%
		\expandafter\@KPointName(0,#2)(\!Kx,\!Ky){}{$\@@KDy$}
	\else
		\!direction{r}{\@KAbsSep}(\!Kx,\!Ky)%
		\expandafter\@KPointName(0,#2)(\!Kx,\!Ky){}{$\@@KDy$}
	\fi
	\ifdim\!Kay\p@>\z@
		\!direction{b}{\@KAbsSep}(\!Kx,\!Ky)%
		\expandafter\@KPointName(#1,0)(\!Kx,\!Ky){}{$\@@KDx$}
	\else
		\!direction{t}{\@KAbsSep}(\!Kx,\!Ky)%
		\expandafter\@KPointName(#1,0)(\!Kx,\!Ky){}{$\@@KDx$}
	\fi
}% End of \@PointCommonXY
	
\def\PointDotX{\@ifstar{\linenodetrue\PointDotX@@@}{\PointDotX@@@}}
\def\PointDotX@@@{\@ifnextchar[{\PointDotX@@}{\PointDotX@@[0.1]}}
\def\PointDotX@@[#1]#2{\@ifnextchar[{\PointDotX@[#1]#2}{\PointDotX@[#1]#2[]}}
\def\PointDotX@[#1]#2[#3]{\@ifnextchar[{\@PointDotX[#1]#2[#3]}{\@PointDotX[#1]#2[#3][]}}
\def\@PointDotX[#1]#2[#3][#4]{%
	\edef\!Ka{\@nameuse{N?#2}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dottedline{#1}(\!Kax,\!Kay)(\!Kax,0)}
	\@@PointCommon{\!Kax}{0}
	\@PointCommon{#2}{#3}{#4}{\!Kax}{0}{x}
}% End of \@PointDotX
	
\def\PointDashX{\@ifstar{\linenodetrue\PointDashX@@@}{\PointDashX@@@}}
\def\PointDashX@@@{\@ifnextchar[{\PointDashX@@}{\PointDashX@@[1]}}
\def\PointDashX@@[#1]#2#3{\@ifnextchar[{\PointDashX@[#1]{#2}{#3}}{\PointDashX@[#1]{#2}{#3}[]}}
\def\PointDashX@[#1]#2#3[#4]{\@ifnextchar[{\@PointDashX[#1]{#2}{#3}[#4]}{\@PointDashX[#1]{#2}{#3}[#4][]}}
\def\@PointDashX[#1]#2#3[#4][#5]{%
	\edef\!Ka{\@nameuse{N?#3}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dashline[#1]{#2}(\!Kax,\!Kay)(\!Kax,0)}
	\@@PointCommon{\!Kax}{0}
	\@PointCommon{#3}{#4}{#5}{\!Kax}{0}{$x$}
}% End of \@PointDashX

\def\PointDotY{\@ifstar{\linenodetrue\PointDotY@@@}{\PointDotY@@@}}
\def\PointDotY@@@{\@ifnextchar[{\PointDotY@@}{\PointDotY@@[0.1]}}
\def\PointDotY@@[#1]#2{\@ifnextchar[{\PointDotY@[#1]#2}{\PointDotY@[#1]#2[]}}
\def\PointDotY@[#1]#2[#3]{\@ifnextchar[{\@PointDotY[#1]#2[#3]}{\@PointDotY[#1]#2[#3][]}}
\def\@PointDotY[#1]#2[#3][#4]{%
	\edef\!Ka{\@nameuse{N?#2}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dottedline{#1}(\!Kax,\!Kay)(0,\!Kay)}
	\@@PointCommon{0}{\!Kay}
	\@PointCommon{#2}{#3}{#4}{0}{\!Kay}{$y$}
}% End of \@PointDotY
	
\def\PointDashY{\@ifstar{\linenodetrue\PointDashY@@@}{\PointDashY@@@}}
\def\PointDashY@@@{\@ifnextchar[{\PointDashY@@}{\PointDashY@@[1]}}
\def\PointDashY@@[#1]#2#3{\@ifnextchar[{\PointDashY@[#1]{#2}{#3}}{\PointDashY@[#1]{#2}{#3}[]}}
\def\PointDashY@[#1]#2#3[#4]{\@ifnextchar[{\@PointDashY[#1]{#2}{#3}[#4]}{\@PointDashY[#1]{#2}{#3}[#4][]}}
\def\@PointDashY[#1]#2#3[#4][#5]{%
	\edef\!Ka{\@nameuse{N?#3}}
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\put(0,0){\dashline[#1]{#2}(\!Kax,\!Kay)(0,\!Kay)}
	\@@PointCommon{0}{\!Kay}
	\@PointCommon{#3}{#4}{#5}{0}{\!Kay}{$y$}
}% End of \@PointDashY
	
\def\@@PointCommon#1#2{%
	\iflinenode% アスタリスクがあると座標軸に小目盛り線を引く
		\@KLenCalc{\KSmallScaleLen}{\@KAbsSepSP}
		\ifdim \KScaleDirectionX\p@>\z@
			\def\@KAbsSepSM{0}
		\else
			\Mul{\@KAbsSepSP}{-1}{\@KAbsSepSM}
		\fi
		\ifdim \KScaleDirectionX\p@<\z@
			\def\@KAbsSepSP{0}
		\fi
		\ifdim#1\p@=\z@\else
			\put(#1,0){\path(0,\@KAbsSepSP)(0,\@KAbsSepSM)}
		\fi
		\ifdim#2\p@=\z@\else
			\put(0,#2){\path(\@KAbsSepSP,0)(\@KAbsSepSM,0)}
		\fi
		\linenodefalse
	\fi
}% End of \@@PointCommon

\def\@PointCommon#1#2#3#4#5#6{%
	\KVecRound(#4,#5)\KFigure(\@@KDx,\@@KDy)
	\def\KSame{#1{}#6}
	\ifdim#4\p@=\z@
		\def\Cnode{$\@@KDy$}
		\def\CnodeY{$\@@KDy$}
		\def\CnodeName{#1{}#6$(\@@KDy)$}
	\else
		\def\Cnode{$\@@KDx$}
		\def\CnodeX{$\@@KDx$}
		\def\CnodeName{#1{}#6$(\@@KDx)$}
	\fi
	\WSeperate{#3}\!Ka\!Kb\!Kc% #3を分解
	\@KLenCalc{\WordSep}{\@KAbsSep}
	\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
	\expandafter\@KPointName(#4,#5)(\!Kx,\!Ky){\!Kb}{#2}
}% End of \@PointCommon
% 20110809 End


% 20110809 Start
%===============================================
% 15．定義した２点を通る直線とx軸またはy軸の交点へ数字を表示する
%===============================================
% 
%  \AxesCrossX{２つの定義点}[文字位置]
%  \AxesCrossY{２つの定義点}[文字位置]
%
\def\AxesCrossX#1{\@ifnextchar[{\@AxesCrossX{#1}}{\@AxesCrossX{#1}[]}}
\def\@AxesCrossX#1[#2]{%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\@VecSub\!Ka\!Kb\!Kc
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\expandafter\KVecScalar\!Kb(\!Kbx,\!Kby)
	\expandafter\KVecScalar\!Kc(\!Kcx,\!Kcy)
	\ifdim\!Kcy\p@=\z@\else% y座標が同じでないとき
		\ifdim\!Kcx\p@=\z@\else% x座標が同じでないとき
			\Div{\!Kcy}{\!Kcx}{\!Kc}
			\Mul{\!Kc}{\!Kax}{\!Kax}
			\Sub{\!Kax}{\!Kay}{\!Kax}
			\Div{\!Kax}{\!Kc}{\!Kax}
		\fi
		\ifdim\!Kax\p@<\@KFrameLeft\p@\else % \!Kxが\@KFrameLeftより大きいか
			\ifdim\!Kax\p@>\@KFrameRight\p@\else % \!Kxが\@KFrameRightより小さいか
				\KRound\!Kax\KFigure\!Kay
				\WSeperate{#2}\!Ka\!Kb\!Kc% #2を分解
				\@KLenCalc{\WordSep}{\@KAbsSep}
				\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
				\expandafter\@KPointName(\!Kax,0)(\!Kx,\!Ky){\!Kb}{$\!Kay$}
			\fi
		\fi
	\fi
}% End of \@AxesCross

\def\AxesCrossY#1{\@ifnextchar[{\@AxesCrossY{#1}}{\@AxesCrossY{#1}[]}}
\def\@AxesCrossY#1[#2]{%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\@VecSub\!Ka\!Kb\!Kc
	\expandafter\KVecScalar\!Ka(\!Kax,\!Kay)
	\expandafter\KVecScalar\!Kb(\!Kbx,\!Kby)
	\expandafter\KVecScalar\!Kc(\!Kcx,\!Kcy)
	\ifdim\!Kcx\p@=\z@\else% x座標が同じでないとき
		\ifdim\!Kcy\p@=\z@\else% y座標が同じでないとき
			\Div{\!Kcy}{\!Kcx}{\!Kc}
			\Mul{\!Kc}{\!Kax}{\!Kax}
			\Sub{\!Kay}{\!Kax}{\!Kay}
		\fi
		\ifdim\!Kay\p@<\@KFrameBottom\p@\else % \!Kxが\@KFrameLeftより大きいか
			\ifdim\!Kay\p@>\@KFrameTop\p@\else % \!Kxが\@KFrameRightより小さいか
				\KRound\!Kay\KFigure\!Kax
				\WSeperate{#2}\!Ka\!Kb\!Kc% #2を分解
				\@KLenCalc{\WordSep}{\@KAbsSep}
				\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
				\expandafter\@KPointName(0,\!Kay)(\!Kx,\!Ky){\!Kb}{$\!Kax$}
			\fi
		\fi
	\fi
}% End of \@AxesCross
% 20110809 End


%===============================================
% 16．node座標をもとに、\putの代わりをする
%===============================================
% 
%  \Kput{nodeで定義した座標名}
%
\def\Kput#1{%
	\edef\!Kt{\@nameuse{N?#1}}
	\expandafter\put\!Kt
}% End of \Kput


%===============================================
% 17．入力した２点のnode座標を半径とする円を描く
%===============================================
%
\def\Kcircle{\@ifstar{\bulletnodetrue\@Kcircle}{\@Kcircle}}
\def\@Kcircle#1{%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Ka{\@nameuse{N?\!Ka}}
	\edef\!Kb{\@nameuse{N?\!Kb}}
	\edef\!Kc{\@nameuse{N?\!Kc}}
	\edef\!Kt{\!Ka\!Kb}%
	\expandafter\Distance\!Kt\!Kt% 距離を計算
	\Add\!Kt\!Kt\!Kt% ２倍
	\ifbulletnode%
		\put(0,0){\circle*{\!Kt}}
	\else%
		\put(0,0){\circle{\!Kt}}
	\fi%
	\bulletnodefalse
}% End of \Kcircle


%===============================================
% 18．node座標で使用するサブマクロ
%===============================================
% 
%-----------------------------------------------
% 空間座標を平面座標へ変換
%-----------------------------------------------
\def\KThreeTwo(#1,#2,#3)(#4,#5){%
	\obcalc(#1,#2)(\@@KDx,\@@KDy)%
	\Add\@@KDy{#3}{#5}
	\Mul\@@KDx{1}{#4}
}% End of \KThreeTwo


%-----------------------------------------------
% 度で表示された角度をラジアンへ変換して、直交座標を出力
%-----------------------------------------------
\def\KPoleToXY(#1,#2)(#3,#4){\@killglue%
	\DegRad{#2}\!KtTheta
	\Cos\!KtTheta\!KX
	\Sin\!KtTheta\!KY
	\Mul\!KX{#1}#3
	\Mul\!KY{#1}#4
\ignorespaces}% End of \KPoleToXY


%-----------------------------------------------
% 入力された文字列#1を１文字ずつ#2#3#4へ分解(最大３文字)
%-----------------------------------------------
\def\KSeperate#1#2#3#4{\@killglue%
	\let\@!Ka\empty
	\let\@!Kb\empty
	\let\@!Kc\empty
	\@tempcnta=\z@
	\@tfor\loop@knode:=#1\do{%
	\advance\@tempcnta\@ne% \@tempcntaを１つ増やす
	\ifnum\@tempcnta=1\let\@!Ka\loop@knode\fi
	\ifnum\@tempcnta=2\let\@!Kb\loop@knode\fi
	\ifnum\@tempcnta=3\let\@!Kc\loop@knode\fi
	}% End of \do
	\let#2=\@!Ka
	\let#3=\@!Kb
	\let#4=\@!Kc
\ignorespaces}% End of KSeperate


%-----------------------------------------------
% 入力された文字列#1をカンマごとに#2#3#4へ分解(最大３ワード)
%-----------------------------------------------
\def\WSeperate#1#2#3#4{\@killglue%
	\let\@!Ka\empty
	\let\@!Kb\empty
	\let\@!Kc\empty
	\@tempcnta=\z@
	\@for\loop@knode:=#1\do{% \KSeperateとの違いはここだけ
	\advance\@tempcnta\@ne% \@tempcntaを１つ増やす
	\ifnum\@tempcnta=1\let\@!Ka\loop@knode\fi
	\ifnum\@tempcnta=2\let\@!Kb\loop@knode\fi
	\ifnum\@tempcnta=3\let\@!Kc\loop@knode\fi
	}% End of \do
	\let#2=\@!Ka
	\let#3=\@!Kb
	\let#4=\@!Kc
\ignorespaces}% End of WSeperate


%-----------------------------------------------
% 入力された文字列#1をカンマごとに#2#3#4#5へ分解(最大４ワード)
%-----------------------------------------------
\def\WSeperateFour#1#2#3#4#5{\@killglue%
	\let\@!Ka\empty
	\let\@!Kb\empty
	\let\@!Kc\empty
	\let\@!Kd\empty
	\@tempcnta=\z@
	\@for\loop@knode:=#1\do{% \KSeperateとの違いはここだけ
	\advance\@tempcnta\@ne% \@tempcntaを１つ増やす
	\ifnum\@tempcnta=1\let\@!Ka\loop@knode\fi
	\ifnum\@tempcnta=2\let\@!Kb\loop@knode\fi
	\ifnum\@tempcnta=3\let\@!Kc\loop@knode\fi
	\ifnum\@tempcnta=4\let\@!Kd\loop@knode\fi
	}% End of \do
	\let#2=\@!Ka
	\let#3=\@!Kb
	\let#4=\@!Kc
	\let#5=\@!Kd
\ignorespaces}% End of WSeperate


%-----------------------------------------------
% \!direction#1#2(#3,#4)
%  ・入力
%    #1:方向の文字が入っている(２文字もあり得る)
%    #2:離す距離が入っている
%  ・出力
%    #3:離すx座標
%    #4:離すy座標
%-----------------------------------------------
\def\!direction#1#2(#3,#4){%
	\def\K!x{0}\def\K!y{0}
	% \expandafterの入れまくり(マクロの八街P21)
	\expandafter\@tfor\expandafter\di!\expandafter:%
	\expandafter=#1\do{%
		% もし、「\di!」が「t(top)」なら、「\K!y」に「#2」を代入
		\def\K!k{t}\if\di!\K!k\let\K!y=#2\fi
		% もし、「\di!」が「b(bottom)」なら、「\K!y」に「-#2」を代入
		\def\K!k{b}\if\di!\K!k\let\K!y=#2\Mul\K!y{-1}\K!y\fi
		% もし、「\di!」が「r(right)」なら、「\K!x」に「#2」を代入
		\def\K!k{r}\if\di!\K!k\let\K!x=#2\fi
		% もし、「\di!」が「l(left)」なら、「\K!x」に「-#2」を代入
		\def\K!k{l}\if\di!\K!k\let\K!x=#2\Mul\K!x{-1}\K!x\fi
	}% End of \do
	\Mul\K!x\K!y\K!xy% \K!xy=\K!x * \K!y
	\ifdim \K!xy\p@=\z@\else% \K!xy<>0
		\Mul\K!x{0.7070}\K!x% 斜めなので補正
		\Mul\K!y{0.7070}\K!y
	\fi
	\let#3=\K!x
	\let#4=\K!y
}% End of \!direction


%-----------------------------------------------
% ？．xy座標で定義された数字を指定した小数点以下の桁数に直して出力
%-----------------------------------------------
%
% (#1,#2)・・・入力する座標
%      #3・・・表示する桁数
% (#4,#5)・・・出力する座標
%
\def\KVecRound(#1,#2)#3(#4,#5){%
	\KRound{#1}{#3}{#4}
	\KRound{#2}{#3}{#5}
}% End of \KVecRound


%-----------------------------------------------
% ？．ベクトルで入っている文字を分解
%-----------------------------------------------
%
% (#1,#2)・・・入力する座標
% (#3,#4)・・・出力する座標
%
\def\KVecScalar(#1,#2)(#3,#4){%
	\def\@Dummy{#1}
	\let#3=\@Dummy
	\def\@Dummy{#2}
	\let#4=\@Dummy
}% End of \KVecScalar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      node座標結ぶマクロ
%         eclarith.styからコピー＆追加
%
%===============================================
% １．node座標を結ぶ線の種類を指定
%===============================================
% eclarith.styの \throughbrush と同じ働きをする
% ただスペルが長いから再定義しただけ。
\def\KPen#1{\@killglue\def\edge@brush{#1}\ignorespaces}


%===============================================
% ２．node座標を結ぶマクロ
%===============================================
% \KPath[\KPenの線種]{結ぶnode座標名,結ぶnode座標名}
% eclarith.styの中の\throughを改良
% 最後の「\put(0,0)」がないと指定した場所とずれるため追加
% 基本的な使用法は \through と同じ
% カンマで区切り、複数の線が結べるようにした
% []で\KPenのを同時使用にした
%
\def\KPath{\@ifnextchar[{\KPath@@}{\KPath@}}
\def\KPath@@[#1]#2{\KPen{#1}\KPath@{#2}}
\def\KPath@#1{\@killglue%
	\let\edge@ends=\empty
	\def\KPathTmp{,}
	\@tfor\curr@node:=#1\do{%
		\if\curr@node\KPathTmp%
			\@KPath%
			\let\edge@ends=\empty
		\else
			\@ifundefined{N?\curr@node}%
			{\typeout{Unknown Knode \@nameuse{N?\curr@node}}\stop}{}%
			\edef\edge@ends{\edge@ends\@nameuse{N?\curr@node}}%
		\fi
	  }% End of \do
	\@KPath
\ignorespaces}

\def\@KPath{\@killglue%
	\let\edge@@brush=\relax
% 20191230 ver226 Start \KArrowHeadFill 判断追加
\ifKArrowHeadFill% 黒く塗れだよと
	\if@KVecArrow% 本当に黒く塗るベクトルだ！
		\expandafter\KArrowHead\edge@ends% 黒く塗りやがれ！
		\KPen{\drawline}% 黒く塗らない矢印なしで
	\fi
\fi
	\edef\edge@ends{\edge@@brush\edge@ends}%
	\let\edge@@brush=\edge@brush
	\put(0,0){\edge@ends}
% 20191230 ver226 End


% 20191229 ver226バク取りStart
		\KPen{\drawline}
% 20191229 ver226バク取りEnd
\ignorespaces}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      ２点を結ぶ線に関するマクロ
%
%===============================================
% １．２点を結ぶ、２点のベクトルを書く
%===============================================
\newif\if@KVecArrow % \@KVecArrowで矢印を付けるかつけないかの判断
\newif\if@KLineArc   % \@KLineArcで２点を表す文字に円弧を付けるかの判断
\newif\if@KDash   % \@KDashで円弧を実線か破線かの判断
% 20120128 Start
\newif\if@KSolid   % \@KSolidで円弧を実線で描く判断
% 20120128 End

% 20191230 ver226 Start
\newif\ifKArrowHeadFill
\KArrowHeadFillfalse
% \KVec等で矢印を塗りすぶつためのスイッチ \arrow との整合性をためつため初期値はfalse
% \KArrowNoHeadFill と一つにしたかったが、向こうが初期値で塗られているので混在しないた作成した
% 20191230 ver226 End

%	\KLine{始点終点のnode座標}[文字][方向,文字位置]
%	\KLineArc{始点終点のnode座標}[文字][方向,文字位置]
%	\KLineDashArc{始点終点のnode座標}[文字][方向,文字位置]
%		始点と終点を結び，名前等を表示
%
%	\KVec{始点終点のnode座標}[文字][方向,文字位置]
%	\KVecArc{始点終点のnode座標}[文字][方向,文字位置]
%	\KVecDashArc{始点終点のnode座標}[文字][方向,文字位置]
%		始点から終点に矢印を引き，名前等を表示
%
\def\KVec{\@KVecArrowtrue\@KLine@@}
\def\KVecArc{\@KVecArrowtrue\@KLineArctrue\@KSolidtrue\@KLine@@}
\def\KVecDashArc{\@KVecArrowtrue\@KLineArctrue\@KDashtrue\@KLine@@}
\def\KLineArc{\@KLineArctrue\@KSolidtrue\@KLine@@}
\def\KLineDashArc{\@KLineArctrue\@KDashtrue\@KLine@@}
\def\KLine{\@KLine@@}

\def\@KLine@@#1{%
	\@ifnextchar[{\@KLine@#1}{\@KLine#1[][]}
}% End of \@KLine@@
\def\@KLine@#1[#2]{%
	\@ifnextchar[{\@KLine#1[#2]}{\@KLine#1[#2][]}
}% End of \@KLine@
\def\@KLine#1[#2][#3]{\@killglue%
	\if@KVecArrow% ベクトルだ！ 
		\@KLenCalc{\KVecHeadSize}{\@KAbsSep}
		\def\ArrowHeadSize{\@KAbsSep}

% 20191230 ver226 Start \KArrowHeadFill 判断追加
		\ifKArrowHeadFill
			\KPen{\drawline}
		\else
			\KPen{\arrow\drawline}
		\fi
		\KPath{#1}
% 20191230 ver226 End

	\else% 直線だ！
%		\@KVecArrowfalse
		\KPen{\drawline}
		\KPath{#1}
	\fi
	\@KLineName#1[#2][#3]% 文字を表示するのはまかせた
	\@KVecArrowfalse
	\@KSolidfalse
\ignorespaces}% End of \@Line


%===============================================
% ２．２点の中点に指定した文字等を表示(線は描かない)
%===============================================
%   \KLineName{２点の座標名}[文字][方向,文字位置]
%   \KLineNameArc{２点の座標名}[文字][方向,文字位置]
%   \KLineNameDashArc{２点の座標名}[文字][方向,文字位置]
%	２点間の線の中点のまわりに名前、数字を表示する
%
\def\KLineNameArc{\@KLineArctrue\@KSolidtrue\KLineName}
\def\KLineNameDashArc{\@KLineArctrue\@KDashtrue\KLineName}
\def\KLineName#1{%
	\@ifnextchar[{\KLineName@#1}{\@KLineName#1[][]}
}% End of \KLineName
\def\KLineName@#1[#2]{%
	\@ifnextchar[{\@KLineName#1[#2]}{\@KLineName#1[#2][]}
}% End of \KLineName@

\def\@KLineName#1[#2][#3]{\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Kt{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\edef\!Kd{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\expandafter\Distance\!Kt\KTrue% 長さを入れる
	\KRound\KTrue\KFigure\KTrue% 四捨五入
	\@KVecAvg\!Kt\!Kt%
	\@KLenCalc{\WordSep}{\@KAbsSep}
	\def\@KLineThree{#3}
	\def\@KLineDirection{right}
	\ifx\@KLineThree\@KLineDirection
		\@KNintySep{#1}{\@KAbsSep}(\!Kx,\!Ky)
	\else
		\def\@KLineDirection{left}
		\ifx\@KLineThree\@KLineDirection
			\@KDivPtrue
			\@KNintySep{#1}{\@KAbsSep}(\!Kx,\!Ky)
		\else
			\WSeperate{#3}{\!Ka}{\!Kb}{\!Kc}% #3を分解
			\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%
		\fi
	\fi
	\edef\!Ka{(\!Kx,\!Ky)}
	\if@KVecArrow% ベクトルだ！
		\def\KSame{$\overrightarrow{\rm #1}$}
	\else% 直線だ！
		\def\KSame{#1}
	\fi
	\expandafter\@KPointName\!Kt(\!Kx,\!Ky){\!Kb}{#2}

	\if@KLineArc
		\@VecAdd\!Kt\!Ka\!Kcenter% 表示する文字の基準点
		\edef\!Kt{\!Kd\!Kcenter}
		\expandafter\@CircumcenterSub\!Kt(\!KX,\!KY)\KRadius

		\@KLenCalc{\KLineArcLenS}{\@KLineArcLenS}
		\@KLenCalc{\KLineArcLenE}{\@KLineArcLenE}
		\Div\@KLineArcLenS\KRadius\@KLineArcLenS
		\Div\@KLineArcLenE\KRadius\@KLineArcLenE
		\KSeperate{#1}\!Ka\!Kbx\!Kc% #1を分解
		\edef\!Kt{\@nameuse{N?\!Ka}\!Kcenter}
		\expandafter\@KVecToAngle\!Kt\@KakuS
		\edef\!Kt{\@nameuse{N?\!Ka}\@nameuse{N?\!Kbx}}
		\expandafter\@KVecToAngle\!Kt\@KakuE
		\ifdim\@KakuS\p@>\@KakuE\p@
			\let\!Kt\!Ka
			\let\!Ka\!Kbx
			\let\!Kbx\!Kt
		\fi

		\edef\!Kt{\@nameuse{N?\!Ka}(\!KX,\!KY)}
		\expandafter\@KVecToAngle\!Kt\@KakuS
		\edef\!Kt{\!Kcenter(\!KX,\!KY)}
		\expandafter\@KVecToAngle\!Kt\@KakuE
		\Sub\@KakuE\@KLineArcLenS\@KakuE
		\edef\!Kt{(\!KX,\!KY)}
		\Mul\KRadius{2}\KDiameter
		\expandafter\@KArcMain[\KDiameter]{\@KakuS}{\@KakuE}{\!Kt}[][]%

% 20120107 バグ取り Start
% 20120128 バグ取り Start
		\if@KSolid\else
			\@KDashtrue
		\fi
% 20120128 バグ取り End
% 20120107 バグ取り End
		\edef\!Kt{\!Kcenter(\!KX,\!KY)}
		\expandafter\@KVecToAngle\!Kt\@KakuS
		\Add\@KakuS\@KLineArcLenE\@KakuS
		\edef\!Kt{\@nameuse{N?\!Kbx}(\!KX,\!KY)}
		\expandafter\@KVecToAngle\!Kt\@KakuE
		\edef\!Kt{(\!KX,\!KY)}
		\Mul\KRadius{2}\KDiameter
		\expandafter\@KArcMain[\KDiameter]{\@KakuS}{\@KakuE}{\!Kt}[][]%
% 20120107 バグ取り Start
%		\@KDashfalse
% 20120107 バグ取り End
		\@KLineArcfalse
	\fi
\ignorespaces}% End of \@KLineName


%===============================================
\def\@KNintySep#1#2(#3,#4){\@killglue%
	\KSeperate{#1}{\!Ka}{\!Kb}{\!Kc}% #1を分解
	\edef\!Kd{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\edef\!Ke{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\@KVecSub\!Ke\!KtSlant%
	\expandafter\@KOrthogonallySlant\!KtSlant(\!KtSlantX,\!KtSlantY)
	\edef\!Ke{(\!KtSlantX,\!KtSlantY)}
	\if@KDivP
		\@SVecMul\!Ke{-1}\!Ke
	\fi
	\edef\!Ke{(0,0)\!Ke}
	\expandafter\@KVecToAngle\!Ke\@Kaku
	\Cos\@Kaku\!KX
	\Mul\!KX{#2}\!KX
	\Sin\@Kaku\!KY
	\Mul\!KY{#2}\!KY
	\let#3=\!KX
	\let#4=\!KY
	\@KDivPfalse
\ignorespaces}% End of \@KNintySep

\def\@KOrthogonallySlant(#1,#2)(#3,#4){\@killglue%
	\ifdim#1\p@=\z@
		\def\!KtSlantX{-1}
		\def\!KtSlant{0}
	\else
		\ifdim#2\p@=\z@
			\def\!KtSlantX{0}
			\def\!KtSlant{#1}
		\else
			\def\!KtSlantX{1}
			\Div{#1}{#2}\!KtSlant
		\fi
	\fi
	\AbsSign\!KtSlant\!KtSlantY\@Dummy
	\ifdim\!KtSlant\p@>\z@
		\ifdim#1\p@>\z@
			\Mul\!KtSlantY{-1}\!KtSlantY
		\else
			\Mul\!KtSlantX{-1}\!KtSlantX
		\fi
	\else
		\ifdim#1\p@>\z@
			\Mul\!KtSlantY{-1}\!KtSlantY
			\Mul\!KtSlantX{-1}\!KtSlantX
		\fi
	\fi
	\let#3=\!KtSlantX
	\let#4=\!KtSlantY
\ignorespaces}% End of @KOrthogonallySlant


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      直角の記号を書くマクロ
%
%===============================================
% ９０度の角を表示
%    \KNinty{ABC}
%    角ABCに直角を書く。\KNinty{CBA}も同じ動作をする
%    角の大きさは\NintyLenで指定。初期値は\NintyLen=2.0mm
%
\def\KNinty#1{\@killglue
	\KSeperate{#1}\!Ka\!Kb\!Kc% #1を分解
	%  \!Kt←(N?\!Ka_x,N?\!Ka_y)(N?\!Kb_x,N?\!Kb_y)を代入
	\edef\!Kt{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\@KVecSub\!Kt\!Kt%
	\@VecUnit\!Kt\K@A

	%  \!Kt←(N?\!Kc_x,N?\!Kc_y)(N?\!Kb_x,N?\!Kb_y)を代入
	\edef\!Kt{\@nameuse{N?\!Kc}\@nameuse{N?\!Kb}}
	\@KVecSub\!Kt\!Kt%
	\@VecUnit\!Kt\K@C

	\@VecAdd{\K@A}{\K@C}{\K@B}% 対角線の相対座標を求める
	\@KLenCalc{\NintyLen}{\@KAbsSep}
	\@SVecMul\K@A{\@KAbsSep}\K@A
	\@SVecMul\K@B{\@KAbsSep}\K@B
	\@SVecMul\K@C{\@KAbsSep}\K@C
	\edef\!Kt{\@nameuse{N?\!Kb}}
	\edef\!Kt{\!Kt\K@A\K@B\K@C}
	\expandafter\@KNinty\!Kt
\ignorespaces}% End of \KNinty

\def\@KNinty(#1,#2)(#3,#4)(#5,#6)(#7,#8){%
	\put(#1,#2){\path(#3,#4)(#5,#6)(#7,#8)}
}% End of \@KNinty


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      角度(円弧)の記号を描くマクロ
%
%===============================================
% １．角度指定で角・一般角を表示
%===============================================
%
%	\KArc[直径](x座標,y座標)(開始角度(°),終了角度(°))[文字][方向,文字位置]
%	\KArc[直径]{node name}(開始角度(°),終了角度(°))[文字][方向,文字位置]
%	\KDashArc 以下\KArcと同じ
%	\ArrowKArc 以下\KArcと同じ
%	\ArrowKDashArc 以下\KArcと同じ
%	\RevArrowKArc 以下\KArcと同じ
%	\RevArrowKDashArc 以下\KArcと同じ
%      eepicの\arcは設定がしづらいので定義
%      一般角の開始角から終了角へ行くように設定
%      角度はわかりやすいように度で設定
%      直径は\AngleLenで設定(初期値 \AngleLen=10mm)
%      \circle,\arcと互換性をとるために直径にした
%
\newif\if@KArrow % \@KArrowで矢印を付けるか付けないかの判断
%\newif\if@KDash   % \@KDashで円弧を実線か破線かの判断(\KLineDashArcで定義済み)
\newif\if@KRev   % \@KRevで矢印が正の方向か負の方向かの判断


\def\@KDegRad#1#2#3#4{\@killglue
	\DegRad{#1}\@KakuS% 開始角をラジアンに変換
	\DegRad{#2}\@KakuE% 終了角をラジアンに変換
	\let#3\@KakuS
	\let#4\@KakuE
\ignorespaces}% End of \@KDegRad

\def\RevArrowKArc{\@KRevtrue\ArrowKArc}% 逆の矢印付
\def\RevArrowKDashArc{\@KDashtrue\@KRevtrue\ArrowKArc}% 逆の矢印付破線
\def\ArrowKArc{\@KArrowtrue\KArc}% 矢印付
\def\ArrowKDashArc{\@KDashtrue\@KArrowtrue\KArc}% 矢印付破線

%\def\KDashArc{\@KDashtrue\@ifnextchar({\@KArcI@@}{\@KArcII@@}}% 破線
\def\KDashArc{\@KDashtrue\KArc}% 破線
\def\KArc{\@ifnextchar[{\@KArc@@@}{\@KArc@@@[]}}

\def\@KArc@@@[#1]{\@ifnextchar({\@KArcI@@[#1]}{\@KArcII@@[#1]}}
\def\@KArcI@@[#1](#2)(#3){%
	\@ifnextchar[{\@KArcI@[#1](#2)(#3)}{\@KArcI[#1](#2)(#3)[][]}
}% End of \@KArcI@@
\def\@KArcI@[#1](#2)(#3)[#4]{%
	\@ifnextchar[{\@KArcI[#1](#2)(#3)[#4]}{\@KArcI[#1](#2)(#3)[#4][]}
}% End of \@KArcI@
\def\@KArcI[#1](#2,#3)(#4,#5)[#6][#7]{\@killglue
	\@KDegRad{#4}{#5}\@KakuS\@KakuE
	\@KArcMain[#1]{\@KakuS}{\@KakuE}{(#2,#3)}[#6][#7]
\ignorespaces}% End of \@KArc

\def\@KArcII@@[#1]#2(#3){%
	\@ifnextchar[{\@KArcII@[#1]#2(#3)}{\@KArcII[#1]#2(#3)[][]}
}% End of \@KArcII@@
\def\@KArcII@[#1]#2(#3)[#4]{%
	\@ifnextchar[{\@KArcII[#1]#2(#3)[#4]}{\@KArcII[#1]#2(#3)[#4][]}
}% End of \@KArcII@
\def\@KArcII[#1]#2(#3,#4)[#5][#6]{\@killglue
	\@KDegRad{#3}{#4}\@KakuS\@KakuE
	\edef\!Kt{\@nameuse{N?#2}}
	\@KArcMain[#1]{\@KakuS}{\@KakuE}{\!Kt}[#5][#6]
\ignorespaces}% End of \@KArcII


%===============================================
% ２．\Pnode指定で角・一般角を表示
%===============================================
%
%	\PAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\PDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\ArrowPDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\ArrowPAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\RevArrowPAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\RevArrowPDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%   ただし、座標は全て\Pnodeで定義されていること
%   \KAngleに比べて高速(角度がわかるので当たり前か！)
%
%         真ん中の角に角の記号を表示する始角原点終角を結ぶ
%
\def\RevArrowPAngle{\@KRevtrue\ArrowPAngle}% 逆の矢印付
\def\RevArrowPDashAngle{\@KDashtrue\@KRevtrue\ArrowPAngle}% 逆の矢印付破線
\def\ArrowPAngle{\@KArrowtrue\PAngle}% 矢印付
\def\ArrowPDashAngle{\@KDashtrue\@KArrowtrue\PAngle}% 矢印付破線

%\def\PDashAngle#1{\@KDashtrue\@ifnextchar[{\@PAngle@#1}{\@PAngle#1[][]}}% 破線
\def\PDashAngle{\@KDashtrue\PAngle}% 破線
\def\PAngle{\@ifnextchar[{\@PAngle@@}{\@PAngle@@[]}}
\def\@PAngle@@[#1]#2{\@ifnextchar[{\@PAngle@[#1]#2}{\@PAngle[#1]#2[][]}}
\def\@PAngle@[#1]#2[#3]{\@ifnextchar[{\@PAngle[#1]#2[#3]}{\@PAngle[#1]#2[#3][]}}

\def\@PAngle[#1]#2[#3][#4]{\@killglue
	\KSeperate{#2}\!Ka\!Kb\!Kc% #1を分解
	\edef\!KtS{\@nameuse{P?\!Ka}}
	\edef\!Ke{\@nameuse{P?\!Kc}}
	\@KDegRad{\!KtS}{\!Ke}\@KakuS\@KakuE
	\@KArcMain[#1]{\@KakuS}{\@KakuE}{(0,0)}[#3][#4]
\ignorespaces}% End of \@PAngle


%===============================================
% ３．node座標指定で角・一般角を表示(時間がかかる)
%===============================================
%
%	\KAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\KDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\ArrowKAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\ArrowKDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\RevArrowKAngle[直径]{３つの座標名}[文字][方向,文字位置]
%	\RevArrowKDashAngle[直径]{３つの座標名}[文字][方向,文字位置]
%
%		真ん中の点に角の記号を表示する（時計の逆周りの順）
%
\def\RevArrowKAngle{\@KRevtrue\ArrowKAngle}% 逆の矢印付
\def\RevArrowKDashAngle{\@KDashtrue\@KRevtrue\ArrowKAngle}% 逆の矢印付破線
\def\ArrowKAngle{\@KArrowtrue\KAngle}% 矢印付
\def\ArrowKDashAngle{\@KDashtrue\@KArrowtrue\KAngle}% 矢印付破線

%\def\KDashAngle#1{\@KDashtrue\@ifnextchar[{\@KAngle@#1}{\@KAngle#1[][]}}% 破線
\def\KDashAngle{\@KDashtrue\KAngle}% 破線
\def\KAngle{\@ifnextchar[{\@KAngle@@}{\@KAngle@@[]}}
\def\@KAngle@@[#1]#2{\@ifnextchar[{\@KAngle@[#1]#2}{\@KAngle[#1]#2[][]}}
\def\@KAngle@[#1]#2[#3]{\@ifnextchar[{\@KAngle[#1]#2[#3]}{\@KAngle[#1]#2[#3][]}}
\def\@KAngle[#1]#2[#3][#4]{\@killglue%
	\KSeperate{#2}\!Ka\!Kb\!Kc% #2を分解
	\edef\!Kt{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\expandafter\@KVecToAngle\!Kt\@KakuS
	\edef\!Kt{\@nameuse{N?\!Kc}\@nameuse{N?\!Kb}}
	\expandafter\@KVecToAngle\!Kt\@KakuE
	\edef\!Kt{\@nameuse{N?\!Kb}}
	\@KArcMain[#1]{\@KakuS}{\@KakuE}{\!Kt}[#3][#4]%
\ignorespaces}% End of \@KAngle

\def\@KVecToAngle(#1,#2)(#3,#4)#5{\@killglue%
	\edef\!Kangle{(#1,#2)(#3,#4)}
	\@KVecSub\!Kangle\!Kangle%
	\@VecUnit\!Kangle\!Kangle
	\expandafter\K!angle\!Kangle\!Kangle
	\let#5=\!Kangle
\ignorespaces}% End of \@KVecToAngle



%===============================================
% ４．角度表示のメインマクロ
%===============================================
%
%	\@KArcMain[直径]{開始角}{終了角}{ここでの原点}[文字][方向,文字位置]
%      円弧を表示し、文字も表示
%      @KArrowtrueなら矢印表示
%      @KRevtrueなら矢印逆
%
\def\@KArcMain[#1]#2#3#4[#5][#6]{\@killglue
	\let\@KakuS#2
	\let\@KakuE#3
	\edef\@KCenterPoint{#4}
	\@whiledim\@KakuS\p@>\@KakuE\p@\do{%
		\Add\@KakuE\Pii\@KakuE
	}% End of do
	\def\!Dummy{#1}
	\ifx\!Dummy\empty
		\@KLenCalc{\AngleLen}{\@KAbsSepLen}
	\else
		\def\@KAbsSepLen{#1}
	\fi
	\KRadArc{\@KakuS}{\@KarcE}
	\KRadArc{\@KakuE}{\@KarcS}
	\if@KDash
		\expandafter\put\@KCenterPoint{\@KDashArc\@KAbsSepLen\@KarcS\@KarcE}
	\else
		\expandafter\put\@KCenterPoint{\arc\@KAbsSepLen\@KarcS\@KarcE}
	\fi
	%
	\Sub\@KakuE\@KakuS\@KakuAll
	\Avg\@KakuS\@KakuE\@KakuAvg
	% 名前・角度を入れる
	\@KArcToXY{\@KAbsSepLen}{\@KakuAvg}{\!Kt}
	\@VecAdd\@KCenterPoint\!Kt\!Kt

	\RadDeg\@KakuAll\@KakuAll
	\WSeperate{#6}\!Ka\!Kb\!Kc% #6を分解
	\@KLenCalc{\WordSep}{\@KAbsSep}
	\!direction{\!Ka}{\@KAbsSep}(\!Kx,\!Ky)%

	\if@KRev
		\Mul\@KakuAll{-1}\@KakuAll
	\fi
	\KRound\@KakuAll\KFigure\@KakuAll% 四捨五入
	\def\KTrue{${\@KakuAll}^{\circ}$}
	\expandafter\@KPointName\!Kt(\!Kx,\!Ky){\!Kb}{#5}
	% 矢印を付ける
	\@KLenCalc{\KArrowLen}{\@KakuB}% 矢の長さ
	\if@KArrow% 矢印を表示する
		\if@KRev% 始点に矢印
			% 終了角の座標計算
			\@KArcToXY{\@KAbsSepLen}{\@KakuS}{\!Kt}
			\Div\@KAbsSepLen{2}\@KAbsSep
			\Div\@KakuB\@KAbsSep\@KakuB
			\Add\@KakuS\@KakuB\@KakuB
			\@KArcToXY{\@KAbsSepLen}{\@KakuB}{\!Ktii}
			\edef\!Kt{\!Ktii\!Kt}
		\else
			% 終了角の座標計算
			\@KArcToXY{\@KAbsSepLen}{\@KakuE}{\!Kt}
			\Div\@KAbsSepLen{2}\@KAbsSep
			\Div\@KakuB\@KAbsSep\@KakuB
			\Sub\@KakuE\@KakuB\@KakuB
			\@KArcToXY{\@KAbsSepLen}{\@KakuB}{\!Ktii}
			\edef\!Kt{\!Ktii\!Kt}
		\fi
		\expandafter\put\@KCenterPoint{\expandafter\KArrowHead\!Kt}
	\fi
	\@KArrowfalse
	\@KRevfalse
% 20111229バグ取り Start
	\@KDashfalse
% 20111229 バグ取り End
\ignorespaces}% End of \@KArcMain


\newif\ifKArrowHeadNoFill% \KArrowHeadNoFilltrue で矢を塗らない
%===============================================
% ４．一般角の時の矢印表示のマクロ
%===============================================
%
%	\KArrowHead
%
%     \ifKArrowHeadNoFillfalse で黒く塗った矢印を表示する
%
%     \ifKArrowHeadNoFilltrue で普通の矢印を表示(きれいでない)
%
\def\KArrowHead(#1,#2)(#3,#4){\@killglue
	% Auto \ArrowHeadSize %%%%% Add by nob
	\Distance(#1,#2)(#3,#4)\KTmp
	\Div\KTmp{24}\KTmp
	\Mul\KTmp{25}\KTmp
	% End Auto
	\def\ArrowHeadSize{\KTmp}
	\ifKArrowHeadNoFill
		\ArrowHead(#1,#2)(#3,#4)
	\else
		\Sub{#3}{#1}\arr!Dx \Sub{#4}{#2}\arr!Dy
		\Unit(\arr!Dx,\arr!Dy)(\arr!Ux,\arr!Uy)%
% 20191230 ver226 Start
		\ifKArrowHeadFill% 黒く塗れだよと
			\if@KVecArrow% ここの円弧での処理でないならこちら
				\@KLenCalc{\KVecHeadSize}{\!ArrowHeadSize}% 矢の長さ"
				\Mul\arr!Ux\!ArrowHeadSize\arr!Sx \Mul\arr!Uy\!ArrowHeadSize\arr!Sy
			\else% \ifKArrowHeadFilltrue で円弧の処理はこちら
				\Mul\arr!Ux\ArrowHeadSize\arr!Sx \Mul\arr!Uy\ArrowHeadSize\arr!Sy
			\fi
		\else% \ifKArrowHeadFillfalse なら円弧の処理でこちら
			\Mul\arr!Ux\ArrowHeadSize\arr!Sx \Mul\arr!Uy\ArrowHeadSize\arr!Sy
		\fi
% 20191230 ver226 End
		\Mul\arr!Sx{-0.96}\arr!Tx \Mul\arr!Sy{-0.28}\arr!Vx
		\Mul\arr!Sx{0.28}\arr!Ty \Mul\arr!Sy{-0.96}\arr!Vy
		\Add\arr!Tx\arr!Vx\arr!Hx \Add\arr!Ty\arr!Vy\arr!Hy
		\Add\arr!Hx{#3}\arr!Lx \Add\arr!Hy{#4}\arr!Ly
		\Sub\arr!Tx\arr!Vx\arr!Hx \Sub\arr!Vy\arr!Ty\arr!Hy
		\Add\arr!Hx{#3}\arr!Rx \Add\arr!Hy{#4}\arr!Ry
		% ここを変更して黒くした
		\put(0,0){\blacken\path(\arr!Lx,\arr!Ly)(#3,#4)(\arr!Rx,\arr!Ry)(\arr!Lx,\arr!Ly)}
	\fi
\ignorespaces}% End of KArrowHead


%===============================================
% ５．ベクトルから角度を求める
%===============================================
\def\K!angle(#1,#2)#3{% #1にX座標を,#2にY座標を入力し、#3 にその角度を出力
	\edef\!Kxx{0}% 0°を代入
	\AbsSign{#1}\@KAbsx\@KSignx
	\AbsSign{#2}\@KAbsy\@KSigny
	\Mul\@KAbsx\@KAbsy\@@KAbs
	\ifdim \@@KAbs\p@<0.0001\p@% ベクトルの絶対値の積が0.0001より小さければ
		% 以下の処理は，角度が４方向の場合
		\ifdim \@KAbsx\p@<0.0001\p@% ベクトルのｘ座標が0.0001より小さければ
			% 90°or 270°，とりあえず90°の値を代入
			\Add\!Kxx{1.570795}\!Kxx% !Kxxをπ/2を代入
			\ifdim #2\p@<\z@% ベクトルのｙ座標が負なら
				% 90°でなく270°だった
				\Add\!Kxx{3.14159}\!Kxx% !Kxxのにπを代入
			\fi
		\else
			\ifdim #1\p@<\z@% ベクトルのｘ座標が負なら
				% 180°の値を代入
				\Add\!Kxx{3.14159}\!Kxx% !Kxxのにπを代入
			\fi
		\fi
	\else
		% 以下は４方向以外の処理
		% ２分法で一般角を求める
		% ｙ座標の絶対値で角度を算出
		% ということは0°<θ<90°の範囲で計算している
		\edef\!Kxa{0}
		\edef\!Kxb{1.570796325}% π/2
		\Sub\!Kxb\!Kxa\@Ksa% \@Ksaに初期値π/2を代入
		\@whiledim\@Ksa\p@>0.0001\p@\do{% \@Ksaが0.0001より大きい間は
			\Add\!Kxa\!Kxb\!Kxx%
			\Div\!Kxx{2}\!Kxx
			\Sin\!Kxx\@!Kx
			\ifdim \@!Kx\p@>\@KAbsy\p@
				\let\!Kxb=\!Kxx
			\else
				\let\!Kxa=\!Kxx
			\fi
			\Sub\!Kxb\!Kxa\@Ksa
		}
	% \!Kxxに0°<θ<90°の角度が入る
		\ifdim #1\p@<\z@
			% ｘ座標が負ならπ−\!Kxx (第２象限か第３象限)
			\Sub{3.141595}\!Kxx\!Kxx
			\ifdim #2\p@<\z@
			% さらにｙ座標も負なら2π−\!Kxx
			% 以上よりこの場合，π+\!Kxx
				\Sub{6.28319}\!Kxx\!Kxx
			\fi
		\else
			\ifdim #2\p@<\z@
			% ｘ座標が正でｙ座標が負(第４象限)
				\Sub{6.28319}\!Kxx\!Kxx
			\fi
		\fi
	\fi
	\let#3\!Kxx
}% End of \K!angle


%===============================================
% ６．円弧を破線で書く
%===============================================
%
% \@KDashArc{直径}{開始角}{終了角}
%
\def\@KDashArc#1#2#3{\@killglue%
	\Div{#1}{2}\KRadius% 半径を計算
	\@KLenCalc{\KDashArcLine}{\@KDashArcLine}
	\@KLenCalc{\KDashArcSpace}{\@KDashArcSpace}
	\Div\@KDashArcLine\KRadius\@KDashArcLine
	\Div\@KDashArcSpace\KRadius\@KDashArcSpace
	\def\!Kt{#2}
	\Add\!Kt\@KDashArcLine\!Kend
	\@whiledim\!Kend\p@<#3\p@\do{% \!Kendが#3より小さい間は
		\put(0,0){\arc{#1}{\!Kt}{\!Kend}}
		\Add\!Kend\@KDashArcSpace\!Kt
		\Add\!Kt\@KDashArcLine\!Kend
	}% End of \do
	\ifdim\!Kt\p@<#3\p@
		\arc{#1}{\!Kt}{#3}
	\fi
\ignorespaces}% End of \@KDashArc


%===============================================
% ６．極座標を直交座標に変換
%===============================================
%
% \@KArcToXY{直径}{角度(Radian)}{xy座標(出力)}
%
\def\@KArcToXY#1#2#3{\@killglue
	\Cos{#2}\@KAx
	\Sin{#2}\@KAy
	\edef\!!Kt{(\@KAx,\@KAy)}
	\Div{#1}{2}\@KArcAbsSep
	\@SVecMul\!!Kt{\@KArcAbsSep}\!!Kt
	\edef#3{\!!Kt}
\ignorespaces}% End of \@KArcToXY


%===============================================
% ７．角度を\arcの角度に変換
%===============================================
%
% \KRadArc{普通の角度(Radian)}{\arc用の角度(Radian・出力)}
%
\def\KRadArc#1#2{\@killglue
	\Sub\Pii{#1}\!Kt
	\let#2\!Kt
\ignorespaces}% End of \KRadArc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%
%      その他のマクロ
%
%===============================================
% １．指定した小数まで表示する
%===============================================
%
%	\KRound{数字}{小数第何位まで表示するか}{出力}
%		表示桁数にマイナスを入れると何もしない
%
\newif\if@KDecimal   % \@KDecimaltrueで小数点以下
\def\KRound#1#2#3{\@killglue
%	\let\@KIntger=#1
	\edef\@KIntger{#1}
	\ifdim #2\p@<\z@\else% 桁数が負ならば何もしない正ならば計算
		\def\@KRound{#2}
		\def\@KRTmp{0}
		\def\@KRoundTmp{0.5}
		\@whiledim\@KRound\p@>\@KRTmp\p@\do{%
			\Div\@KRoundTmp{10}\@KRoundTmp
			\Add\@KRTmp{1}\@KRTmp
		}% End of do
		\ifdim\@KIntger\p@>\z@
			\Add\@KIntger\@KRoundTmp\@KIntger
		\else
			\Sub\@KIntger\@KRoundTmp\@KIntger
		\fi
		\def\@KRoundTmp{.}
		\let\@NewRound=\empty
		\def\@KRTmp{0}
		% \expandafterの入れまくり(マクロの八街P21)
		\expandafter\@tfor\expandafter\loop@knode\expandafter:%
		\expandafter=\@KIntger\do{%
			\if@KDecimal% 小数点以下
				\ifdim\@KRound\p@>\@KRTmp\p@
					\edef\@NewRound{\@NewRound\loop@knode}
					\Add\@KRTmp{1}\@KRTmp
				\fi
			\else
				\if\@KRoundTmp\loop@knode
					\@KDecimaltrue
					\ifdim\@KRound\p@=\z@\else
						\edef\@NewRound{\@NewRound\@KRoundTmp}
					\fi
				\else
					\edef\@NewRound{\@NewRound\loop@knode}
				\fi
			\fi
		\let\@KIntger=\@NewRound
		}% End of \do
	\fi
	\@KDecimalfalse
	\let#3=\@KIntger
\ignorespaces}% End of \KRound

%===============================================
% ２．入力した小数を整数にする
%===============================================
%
\def\Int#1.#2to#3{\@killglue%
	\def\@!Ka{#1}
	\let#3\@!Ka
\ignorespaces}


%===============================================
% ３．現在の\unitlengthに対して絶対値で計算
%===============================================
% 文字，90°，角の表示を現在の\unitlengthに対して絶対値で計算
% 途中で変わる可能性があるので毎回計算
\def\@KLenCalc#1#2{% 
	\!Eval\unitlength\!unitlen
	\!Eval{#1}\!KAbsSep
	\Div\!KAbsSep\!unitlen\!KAbsSep
	\let#2=\!KAbsSep
}% End of \@KLenCalc


% 20110507 Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \AreaClear#1 で指定した領域を白くするように定義
%
%=========================================================
% \AreaClear{#1}
%
\def\AreaClear#1{%
	\KPath[\whiten\path]{#1}
	\color{white}
	\KPath[\path]{#1}
	\color{black}
}% 20110507 End


% 共通の命令
\def\@LeftBottom{(\@KFrameLeft,\@KFrameBottom)}
\def\@LeftTop{(\@KFrameLeft,\@KFrameTop)}
\def\@RightBottom{(\@KFrameRight,\@KFrameBottom)}
\def\@RightTop{(\@KFrameRight,\@KFrameTop)}
\newif\if@Kwaku % \@Kwakuで周りに枠を付けるかつけないかの判断
\newif\if@CircleInsideDomain
\newif\if@UpperDomain
\newif\if@firstUpperDomain
\newif\if@secondUpperDomain
\newif\if@Kthicklines
\newif\if@notequalline
% 20120101 Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \KhatchAll[*][#1]   で環境内全てに斜線が入るよう定義
%
%=============================================================
% \KhatchAll[*][m]
%		*・・・枠を描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可,m))
%			[#1]を省略した場合は[1]とする
%
\def\KhatchAll{\@ifstar{\@KhatchAll@@@}{\@KhatchAll@@}}
\def\@KhatchAll@@@{\@ifnextchar[{\@KhatchAll@}{\@KhatchAll@[1]}}
\def\@KhatchAll@@{\@ifnextchar[{\@KhatchAll}{\@KhatchAll[1]}}
\def\@KhatchAll@[#1]{\@killglue%
	\put(0,0){\path(\@KFrameLeft,\@KFrameBottom)(\@KFrameRight,\@KFrameBottom)(\@KFrameRight,\@KFrameTop)(\@KFrameLeft,\@KFrameTop)(\@KFrameLeft,\@KFrameBottom)}
	\@KhatchAll[#1]
\ignorespaces}% End of \@Khatch@

\def\@KhatchAll[#1]{\@killglue
	\@Khatch[#1](\@KFrameLeft,\@KFrameBottom)(\@KFrameRight,\@KFrameTop)\ignorespaces
}% End of \@KhatchAll
% 20120107 End


% 20111231 Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \Khatch[*][#1](#2,#3)(#4,#5)
%
%======================================================================
% \Khatch[*][m](x1,y1)(x2,y2)
%		*・・・枠を描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可,m))
%			[#1]を省略した場合は[1]とする
%		(#2,#3)	・・・長方形の左下の座標
%		(#4,#5)	・・・長方形の右上の座標
%
\def\Khatch{\@ifstar{\@Kwakutrue\@Khatch@@}{\@Khatch@@}}
\def\@Khatch@@{\@ifnextchar[{\@Khatch@}{\@Khatch@[1]}}
\def\@Khatch@[#1]{\@ifnextchar({\@Khatch[#1]}{\@KhatchNode[#1]}}

\def\@KhatchNode[#1]#2{\@killglue%
	\KSeperate{#2}\KTmpA\KTmpB\KTmpC
	\edef\KTmpA{\@nameuse{N?\KTmpA}}
	\edef\KTmpB{\@nameuse{N?\KTmpB}}
	\@VecExchange\KTmpA\KTmpB\KTmpC\KTmpD
	\let\edge@@brush=\relax
	\edef\edge@ends{\edge@@brush[#1]\KTmpC\KTmpD}
	\let\edge@@brush=\@Khatch
	\edge@ends
\ignorespaces}% End of \@KhatchNode

\def\@Khatch[#1](#2,#3)(#4,#5){\@killglue%
	\@KLenCalc{\KDomainInterval}{\@KAbsSep}
	\Mul{#1}{#1}\sh!d
	\Add\sh!d{1}\sh!d
	\Sqroot\sh!d\sh!d
	\Mul\sh!d\@KAbsSep\sh!d% 線の間隔(増分)
	\ifdim#1\p@>\z@% 傾きが正
		\Sub{#4}{#2}\sh!W% 横の長さ
		\Mul{#1}\sh!W\sh!Max
		\Sub{#5}\sh!d\sh!h% 変数
		\Add{#5}\sh!Max\sh!y
		\Sub\sh!y\sh!d\sh!y
		\Sub{#3}\sh!Max\sh!Max% 最終値(ｙ座標)
		\@whiledim\sh!h\p@>\sh!Max\p@\do{%
			\def\sh!xi{#2}
			\def\sh!xii{#4}
			\def\sh!yi{\sh!h}
			\def\sh!yii{\sh!y}
			\ifdim\sh!y\p@>#5\p@
				\@KhatchSub{#1}{#2}{#5}{\sh!xii}{\sh!yii}
			\fi
			\ifdim\sh!h\p@<#3\p@
				\@KhatchSub{#1}{#2}{#3}{\sh!xi}{\sh!yi}
			\fi
			\put(0,0){\path(\sh!xi,\sh!yi)(\sh!xii,\sh!yii)}
			\Sub\sh!h\sh!d\sh!h
			\Sub\sh!y\sh!d\sh!y}
	\else% 傾きがゼロか負
		\Sub{#2}{#4}\sh!W% 横の長さ
		\Mul{#1}\sh!W\sh!Max
		\Sub{#5}\sh!d\sh!h% 変数
		\Add\sh!h\sh!Max\sh!h% 上の分を足す
		\def\sh!y{#5}
		\Sub\sh!y\sh!d\sh!y
		\Sub{#3}{0}\sh!Max% 最終値(ｙ座標)
		\@whiledim\sh!h\p@>\sh!Max\p@\do{%
			\def\sh!xi{#2}
			\def\sh!xii{#4}
			\def\sh!yi{\sh!h}
			\def\sh!yii{\sh!y}
			\ifdim\sh!h\p@>#5\p@
				\@KhatchSub{#1}{#2}{#5}{\sh!xi}{\sh!yi}
			\fi
			\ifdim\sh!y\p@<#3\p@
				\@KhatchSub{#1}{#2}{#3}{\sh!xii}{\sh!yii}
			\fi
			\put(0,0){\path(\sh!xi,\sh!yi)(\sh!xii,\sh!yii)}
			\Sub\sh!h\sh!d\sh!h
			\Sub\sh!y\sh!d\sh!y}
	\fi
	\if@Kwaku
		\put(0,0){\path(#2,#3)(#4,#3)(#4,#5)(#2,#5)(#2,#3)}
		\@Kwakufalse
	\fi
\ignorespaces}% End of \@Khatch


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%
%	\@Khatchのサブルーチン
%
%		#1・・・傾き
%		#2・・・もとのx1座標
%		#3・・・確定y座標
%		#4・・・返すx座標
%		#5・・・返すy座標
\def\@KhatchSub#1#2#3#4#5{\@killglue%
	\Mul{#2}{#1}\sh!tmp
	\Sub\sh!tmp\sh!h\sh!tmp
	\Mul\sh!tmp{-1}\sh!tmp
	\Sub{#3}\sh!tmp\sh!tmp
	\Div\sh!tmp{#1}\sh!tmp
	\edef#4{\sh!tmp}
	\edef#5{#3}
\ignorespaces}% End of \@KhatchSub
% 20111231 End


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% このマクロは、\Khatch でも使用する
%
%---------------------------------------------------------
% 左下と右上座標をに置き換える
% (#1,#2) と (#3,#4) を対角とする長方形の左下の座標を (#5,#6) へ、右上の座標を(#7,#8)へ書き出す
\def\VecExchange(#1,#2)(#3,#4)(#5,#6)(#7,#8){%
	\ifdim#1\p@<#3\p@
		\Add{#1}{0}{#5}\Add{#3}{0}{#7}
	\else
		\Add{#3}{0}{#5}\Add{#1}{0}{#7}
	\fi
	\ifdim#2\p@<#4\p@
		\Add{#2}{0}{#6}\Add{#4}{0}{#8}
	\else
		\Add{#4}{0}{#6}\Add{#2}{0}{#8}
	\fi
}

% 名前で定義された変数を #3#4 へ書き出す
\def\@VecExchange#1#2#3#4{%                \@VecExchange\A\B\C\D
  \let\!!x=\relax \let\!!y=\relax% \!!x と \!!y を空にしておく
  \let\!!xx=\relax \let\!!yy=\relax% \!!x と \!!y を空にしておく
  \edef\!!Vec{#1#2(\!!x,\!!y)(\!!xx,\!!yy)}%    \!!Vec = \A\B(\!!x,\!!y)(\!!xx,\!!yy)
  \expandafter\VecExchange\!!Vec%      \!!Vec を展開して\@VecAddへ渡す
  \edef#3{(\!!x,\!!y)}%           (\!!x,\!!y)を\Cで定義
  \edef#4{(\!!xx,\!!yy)}}%           (\!!xx,\!!yy)を\Dで定義

% 20111231 Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      円の領域を斜線で図示
%
%=============================
%
%	\Khatchcircle[*][#1]{#2}
%		*・・・枠を描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可)
%		#2・・・直径
%		[#1]を省略した場合は[1]とする
%
\def\Khatchcircle{\@ifstar{\@Khatchcircle@@@}{\@Khatchcircle@@}}
\def\@Khatchcircle@@@{\@ifnextchar[{\@Khatchcircle@}{\@Khatchcircle@[1]}}
\def\@Khatchcircle@@{\@ifnextchar[{\@Khatchcircle}{\@Khatchcircle[1]}}
\def\@Khatchcircle@[#1]#2{\@killglue%
	\put(0,0){\circle{#2}}
	\put(0,0){\@Khatchcircle[#1]{#2}}
\ignorespaces}% End of \@Khatchcircle@

\def\@Khatchcircle[#1]#2{%
	\@KLenCalc{\KDomainInterval}{\@KAbsSep}
	\Mul{#1}{#1}\sh!d
	\Add\sh!d{1}\sh!d
	\Sqroot\sh!d\sh!d
	\Mul\sh!d\@KAbsSep\sh!d% 線の間隔(増分)
	\Div{#2}{2}\sh!r% 半径
	\Add{#1}{0}\sh!Max% 最終値 (#1^{2} + 1)*sh!r^{2} の計算
	\Mul\sh!Max\sh!Max\sh!Max%
	\Add\sh!Max{1}\sh!Max%
	\Add\sh!Max{0}\sh!D% #1^{2} + 1 は分母で使用するため
	\Mul\sh!Max\sh!r\sh!Max%
	\Mul\sh!Max\sh!r\sh!Max% 最終値が出来た
	\Add{0}{0}\sh!h% 変数
	\Add{0}{0}\sh!hh% 変数(2乗したものが入る)
		\@whiledim\sh!hh\p@<\sh!Max\p@\do{%
			\Mul\sh!h\sh!h\sh!tmpii
			\Mul\sh!tmpii{-1}\sh!tmpii
			\Add\sh!tmpii\sh!Max\sh!tmpii
			\Sqroot\sh!tmpii\sh!tmpii% ルートの中
			\Div\sh!tmpii\sh!D\sh!tmpii% xの後半

			\Mul{#1}\sh!h\sh!tmpi
			\Mul\sh!tmpi{-1}\sh!tmpi
			\Div\sh!tmpi\sh!D\sh!tmpi% xの前半

			\Add\sh!tmpi\sh!tmpii\sh!xi
			\Mul\sh!xi{#1}\sh!yi
			\Add\sh!yi\sh!h\sh!yi
			\Sub\sh!tmpi\sh!tmpii\sh!xii
			\Mul\sh!xii{#1}\sh!yii
			\Add\sh!yii\sh!h\sh!yii
			\put(0,0){\path(\sh!xi,\sh!yi)(\sh!xii,\sh!yii)}

			\Mul\sh!xi{-1}\sh!xi
			\Mul\sh!yi{-1}\sh!yi
			\Mul\sh!xii{-1}\sh!xii
			\Mul\sh!yii{-1}\sh!yii
			\put(0,0){\path(\sh!xi,\sh!yi)(\sh!xii,\sh!yii)}

		\Add\sh!h\sh!d\sh!h
		\Mul\sh!h\sh!h\sh!hh}%
}% End of \@Khatchcircle
% 20111231 End


% 20120101 Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \CircleInside(Outside)Domain[*][m][O](x,y){d}
%      \CircleInside(Outside)Domain[*][m][O]{A}{d}
%
%======================================================
%	\CircleInside(Outside)Domain[*][#1][#2](#3,#4){#5}
%		*・・・枠を\thicklinesで描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可)
%		#2・・・原点Oの位置(省略時はlb)
%		[#1][#2]を省略した場合は[1,lb]とする
%		#3・・・中心のx座標
%		#4・・・中心のy座標
%		#5・・・直径
%	\CircleInside(Outside)Domain[*][#1][#2]{#3}{#4}
%		#1,#2・・・上と同じ
%		#3・・・node座標
%		#4・・・直径
%=======================================================================
\def\NotCircleInsideDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!CID@@@}{\!CID@@@}}

\def\CircleInsideDomain{\@ifstar{\@Kthicklinestrue\!CID@@@}{\!CID@@@}}
\def\!CID@@@{\@CircleInsideDomaintrue\@ifnextchar[{\!CID@@}{\!CID@@[1]}}
\def\!CID@@[#1]{\@ifnextchar[{\!CID@[#1]}{\!CID@[#1][lb]}}
\def\!CID@[#1][#2]{\@ifnextchar({\!UCD[#1][#2]}{\!UCDNode[#1][#2]}}

\def\NotCircleOutsideDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!COD@@@}{\!COD@@@}}

\def\CircleOutsideDomain{\@ifstar{\@Kthicklinestrue\!COD@@@}{\!COD@@@}}
\def\!COD@@@{\@ifnextchar[{\!COD@@}{\!COD@@[1]}}
\def\!COD@@[#1]{\@ifnextchar[{\!COD@[#1]}{\!COD@[#1][lb]}}
\def\!COD@[#1][#2]{\@ifnextchar({\!UCD[#1][#2]}{\!UCDNode[#1][#2]}}

%======================================================================
\def\!UCDNode[#1][#2]#3#4{%
	\edef\!Kt{\@nameuse{N?#3}}
	\expandafter\KVecScalar\!Kt(\!Kdx,\!Kdy)
	\!UCD[#1][#2](\!Kdx,\!Kdy)#4
}% End of \!CODNode

\def\!UCD[#1][#2](#3,#4)#5{%
	\if@CircleInsideDomain
		\put(#3,#4){\Khatchcircle[#1]{#5}}
	\else
		\KhatchAll[#1]
		\put(#3,#4){\whiten\circle{#5}}
	\fi
	\if@notequalline
		\put(#3,#4){\allinethickness{\KDomainLineBetween}{\put(0,0){\color{white}{\circle{#5}}}}\thinlines}
		\@notequallinefalse
	\fi
	\KAxesAuto[#2]
	\if@Kthicklines
		\thicklines
		\put(#3,#4){\circle{#5}}
		\thinlines
		\@Kthicklinesfalse
	\else
		\put(#3,#4){\circle{#5}}
	\fi
	\@CircleInsideDomainfalse
}% End of \!UCD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \CircleInside(Outside)LineUpperDomain[*][m][O](x,y){d}{2点の座標名}
%      \CircleInside(Outside)LineUpperDomain[*][m][O]{A}{d}{2点の座標名}
%      \CircleInside(Outside)LineLowerDomain[*][m][O](x,y){d}{2点の座標名}
%      \CircleInside(Outside)LineLowerDomain[*][m][O]{A}{d}{2点の座標名}
%
%===========================================================================
% \CircleInside(Outside)LineUpper(Lower)Domain[*][#1][#2](#3,#4){#5}{#6}
%		*・・・直線を太く(thicklines)描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可,m)
%		#2・・・原点Oの位置
%			[#1][#2]を省略した場合は[1][lb]とする
%			(Schlgraph2.styの初期値と同じにした)
%		#3・・・中心のx座標
%		#4・・・中心のy座標
%		#5・・・直径
%		#6・・・直線の領域の上と下のnode座標名
% \CircleInside(Outside)LineUpper(Lower)Domain[*][#1][#2]{#3}{#4}{#5}
%		#1,#2・・・上と同じ
%		#3・・・node座標
%		#4・・・直径
%		#5・・・直線の領域の上と下のnode座標名
%=======================================================================
\def\NotCircleInsideLineUpperDomain{\@notequallinetrue\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!CILD@@@}{\!CILD@@@}}
\def\NotCircleInsideLineLowerDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!CILD@@@}{\!CILD@@@}}

\def\CircleInsideLineUpperDomain{\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!CILD@@@}{\!CILD@@@}}
\def\CircleInsideLineLowerDomain{\@ifstar{\@Kthicklinestrue\!CILD@@@}{\!CILD@@@}}

\def\!CILD@@@{\@CircleInsideDomaintrue\@ifnextchar[{\!CILD@@}{\!CILD@@[1]}}
\def\!CILD@@[#1]{\@ifnextchar[{\!CILD@[#1]}{\!CILD@[#1][lb]}}
\def\!CILD@[#1][#2]{\@ifnextchar({\!UCLD[#1][#2]}{\!UCLDNode[#1][#2]}}

\def\NotCircleOutsideLineUpperDomain{\@notequallinetrue\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!COLD@@@}{\!COLD@@@}}
\def\NotCircleOutsideLineLowerDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!COLD@@@}{\!COLD@@@}}

\def\CircleOutsideLineUpperDomain{\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!COLD@@@}{\!COLD@@@}}
\def\CircleOutsideLineLowerDomain{\@ifstar{\@Kthicklinestrue\!COLD@@@}{\!COLD@@@}}

\def\!COLD@@@{\@ifnextchar[{\!COLD@@}{\!COLD@@[1]}}
\def\!COLD@@[#1]{\@ifnextchar[{\!COLD@[#1]}{\!COLD@[#1][lb]}}
\def\!COLD@[#1][#2]{\@ifnextchar({\!UCLD[#1][#2]}{\!UCLDNode[#1][#2]}}

%=========================================================================
\def\!UCLDNode[#1][#2]#3#4#5{%
	\edef\!!Kt{\@nameuse{N?#3}}
	\expandafter\KVecScalar\!!Kt(\!Kdx,\!Kdy)
	\!UCLD[#1][#2](\!Kdx,\!Kdy){#4}{#5}
}% End of \!UCLDNode

\def\!UCLD[#1][#2](#3,#4)#5#6{%
	\if@CircleInsideDomain
		\put(#3,#4){\Khatchcircle[#1]{#5}}
		\LineDomainSub@{#6}
	\else
		\KhatchAll[#1]
		\LineDomainSub@{#6}
		\put(#3,#4){\whiten\circle{#5}}
	\fi
		\if@notequalline
			\put(#3,#4){\allinethickness{\KDomainLineBetween}{\put(0,0){\color{white}{\circle{#5}}}}\thinlines}
			\@notequallinefalse
		\fi
	\KAxesAuto[#2]
	\if@Kthicklines
		\thicklines
		\KPath{#6}
		\put(#3,#4){\circle{#5}}
		\thinlines
		\@Kthicklinesfalse
	\else
		\KPath{#6}
		\put(#3,#4){\circle{#5}}
	\fi
	\@CircleInsideDomainfalse
}% End of \!UCLD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \LineUpperUpperDomain[*][m][O]{2点の座標名}{2点の座標名}
%      \LineUpperLowerDomain[*][m][O]{2点の座標名}{2点の座標名}
%      \LineLowerUpperDomain[*][m][O]{2点の座標名}{2点の座標名}
%      \LineLowerLowerDomain[*][m][O]{2点の座標名}{2点の座標名}
%
%================================================================
% \LineUpper(Lower)Upper(Lower)Domain[*][#1][#2]{#3}{#4}
%		*・・・直線を太く(thicklines)描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可,m)
%		#2・・・原点Oの位置
%			[#1][#2]を省略した場合は[1][lb]とする
%		#3・・・直線の領域の上と下のnode座標名
%		#4・・・直線の領域の上と下のnode座標名
%
\def\NotLineUpperUpperDomain{\@notequallinetrue\@firstUpperDomaintrue\@secondUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\NotLineUpperLowerDomain{\@notequallinetrue\@firstUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\NotLineLowerUpperDomain{\@notequallinetrue\@secondUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\NotLineLowerLowerDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}

\def\LineUpperUpperDomain{\@firstUpperDomaintrue\@secondUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\LineUpperLowerDomain{\@firstUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\LineLowerUpperDomain{\@secondUpperDomaintrue\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}
\def\LineLowerLowerDomain{\@ifstar{\@Kthicklinestrue\!DLD@@@}{\!DLD@@@}}

\def\!DLD@@@{\@ifnextchar[{\!DLD@@}{\!DLD@@[1]}}
\def\!DLD@@[#1]{\@ifnextchar[{\!DLD@[#1]}{\!DLD@[#1][lb]}}

\def\!DLD@[#1][#2]#3#4{%
	\KhatchAll[#1]
	\if@firstUpperDomain
		\@UpperDomaintrue
		\LineDomainSub@{#3}
	\else
		\LineDomainSub@{#3}
	\fi
	\if@secondUpperDomain
		\@UpperDomaintrue
		\LineDomainSub@{#4}
	\else
		\LineDomainSub@{#4}
	\fi
	\KAxesAuto[#2]
	\if@Kthicklines
		\thicklines
		\KPath{#3,#4}
		\thinlines
		\@Kthicklinesfalse
	\else
		\KPath{#3,#4}
	\fi
	\@firstUpperDomainfalse
	\@secondUpperDomainfalse
	\@notequallinefalse
}% End of \DoubleLineDomain@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%      \LineUpperDomain*[m][O]{2点の座標名}
%      \LineLowerDomain*[m][O]{2点の座標名}
%
%====================================================================
% \LineUpper(Lower)Domain[*][#1][#2]{#3}
%		*・・・直線を太く(thicklines)描く(省略可能)
%		#1・・・斜線の傾き（負の数も指定可,m)
%		#2・・・原点Oの位置(省略した場合は左下
%			[#1][#2]を省略した場合は[1][lb]とする
%		#3・・・直線の領域の上と下のnode座標名
%
\def\NotLineUpperDomain{\@notequallinetrue\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!LD@@@}{\!LD@@@}}
\def\NotLineLowerDomain{\@notequallinetrue\@ifstar{\@Kthicklinestrue\!LD@@@}{\!LD@@@}}

\def\LineUpperDomain{\@UpperDomaintrue\@ifstar{\@Kthicklinestrue\!LD@@@}{\!LD@@@}}
\def\LineLowerDomain{\@ifstar{\@Kthicklinestrue\!LD@@@}{\!LD@@@}}

\def\!LD@@@{\@ifnextchar[{\!LD@@}{\!LD@@[1]}}
\def\!LD@@[#1]{\@ifnextchar[{\!LD@[#1]}{\!LD@[#1][lb]}}

\def\!LD@[#1][#2]#3{%
	\KhatchAll[#1]
	\LineDomainSub@{#3}
	\KAxesAuto[#2]
	\if@Kthicklines
		\thicklines
		\KPath{#3}
		\thinlines
		\@Kthicklinesfalse
	\else
		\KPath{#3}
	\fi
	\@notequallinefalse
}% End of \LineUpper(Lower)Domain


\def\LineDomainSub@#1{%
	\KSeperate{#1}\!Ka\!Kb\!Kc% #1を分解
	\edef\!Kt{\@nameuse{N?\!Ka}\@nameuse{N?\!Kb}}
	\@KVecSub\!Kt\!Kt%
	\@VecUnit\!Kt\K@A% 傾きの計算
	\expandafter\KVecScalar\K@A(\!Kcx,\!Kcy)
	\edef\K@B{\!Kcx}% 分子が正か負か
	\Div\!Kcy\!Kcx\K@A% 傾きが正か負かを調べる
	\edef\!Kaa{\@nameuse{N?\!Ka}}
	\edef\!Kbb{\@nameuse{N?\!Kb}}
	\ifdim\K@B\p@<\z@% どっちが左か傾きの分子で代入
		\expandafter\KVecScalar\!Kaa(\!Klx,\!Kly)
		\expandafter\KVecScalar\!Kbb(\!Krx,\!Kry)
	\else
		\expandafter\KVecScalar\!Kaa(\!Krx,\!Kry)
		\expandafter\KVecScalar\!Kbb(\!Klx,\!Kly)
	\fi
	\def\@Kl{(\!Klx,\!Kly)}
	\def\@Kr{(\!Krx,\!Kry)}
	\let\edge@ends=\empty
	\if@UpperDomain
		\ifdim\K@A\p@>\z@% 傾き正
			\ifdim\!Krx\p@<\@KFrameRight\p@
				\edef\edge@ends{\@RightTop}
			\fi
			\edef\edge@ends{\edge@ends\@RightBottom}
			\ifdim\!Klx\p@>\@KFrameRight\p@\else
				\edef\edge@ends{\edge@ends\@LeftBottom}
			\fi
		\else% 傾き負
			\ifdim\!Krx\p@<\@KFrameRight\p@\else
				\edef\edge@ends{\@RightBottom}
			\fi
			\edef\edge@ends{\edge@ends\@LeftBottom}
			\ifdim\!Klx\p@>\@KFrameLeft\p@
				\edef\edge@ends{\edge@ends\@LeftTop}
			\fi
		\fi
	\else
		\ifdim\K@A\p@>\z@% 傾き正
			\ifdim\!Krx\p@<\@KFrameRight\p@\else
				\edef\edge@ends{\edge@ends\@RightTop}
			\fi
			\edef\edge@ends{\edge@ends\@LeftTop}
			\ifdim\!Klx\p@>\@KFrameLeft\p@
				\edef\edge@ends{\edge@ends\@LeftBottom}
			\fi
		\else% 傾き負
			\ifdim\!Krx\p@<\@KFrameRight\p@
				\edef\edge@ends{\edge@ends\@RightBottom}
			\fi
			\edef\edge@ends{\edge@ends\@RightTop}
			\ifdim\!Klx\p@>\@KFrameLeft\p@\else
				\edef\edge@ends{\edge@ends\@LeftTop}
			\fi
		\fi
	\fi
	\let\edge@@brush=\relax
	\edef\edge@endss{\whiten\edge@@brush\@Kl\@Kr\edge@ends\@Kl}
	\let\edge@@brush=\path
	\put(0,0){\edge@endss}
	\let\edge@@brush=\relax
	\edef\edge@endss{\edge@@brush\@Kl\@Kr}
	\let\edge@@brush=\path
	\if@notequalline
		\put(0,0){\allinethickness{\KDomainLineBetween}{\put(0,0){\color{white}{\edge@endss}\thinlines}}}
	\fi
	\put(0,0){\color{white}{\edge@endss}}
	\let\edge@@brush=\relax
	\edef\edge@endss{\edge@@brush\@Kr\edge@ends\@Kl}
	\let\edge@@brush=\path
	\put(0,0){\thicklines\color{white}{\edge@endss}\thinlines}
	\@UpperDomainfalse
}% End of \LineDomainSub@

\catcode`\!=\orig@colon
